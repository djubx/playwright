```markdown
<!-- START_DESCRIPTION -->
# Native Stack Traces Flutter Package

The `native_stack_traces` Flutter package is a powerful tool designed to help developers capture and analyze native stack traces in their Flutter applications. This package is particularly useful for debugging and diagnosing issues that occur in the native layers of your app, such as crashes or performance bottlenecks. 

## When to Use This Package

You should consider using the `native_stack_traces` package in scenarios such as:
- **Debugging Crashes**: When your Flutter app crashes unexpectedly, capturing the native stack trace can provide insights into what went wrong.
- **Performance Monitoring**: If you are experiencing performance issues, analyzing native stack traces can help identify bottlenecks in the native code.
- **Error Reporting**: Integrating this package with your error reporting tools can enhance the information you collect about crashes.

## Features

- **Cross-Platform Support**: Works seamlessly on both Android and iOS platforms.
- **Easy Integration**: Simple setup process that allows you to start capturing stack traces quickly.
- **Detailed Stack Information**: Provides comprehensive details about the stack trace, including function names and line numbers.

By leveraging the `native_stack_traces` package, developers can gain deeper insights into their applications, leading to more robust and reliable software.

<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
# Tutorial: Setting Up and Using the Native Stack Traces Package

## Step 1: Add Dependency

To get started, add the `native_stack_traces` package to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  native_stack_traces: ^latest_version
```

Make sure to replace `^latest_version` with the latest version of the package available on [pub.dev](https://pub.dev/packages/native_stack_traces).

## Step 2: Platform-Specific Configuration

### Android Configuration

1. Open your `android/app/build.gradle` file.
2. Ensure that you have the following configurations:

```groovy
android {
    ...
    defaultConfig {
        ...
        // Enable native stack traces
        ndk {
            abiFilters "armeabi-v7a", "arm64-v8a", "x86", "x86_64"
        }
    }
}
```

### iOS Configuration

1. Open your `ios/Runner/Info.plist` file.
2. Add the following key to enable stack trace capturing:

```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```

## Step 3: Using the Package

In your Dart code, you can start using the `native_stack_traces` package as follows:

```dart
import 'package:flutter/material.dart';
import 'package:native_stack_traces/native_stack_traces.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Native Stack Traces Demo',
      home: StackTraceDemo(),
    );
  }
}

class StackTraceDemo extends StatefulWidget {
  @override
  _StackTraceDemoState createState() => _StackTraceDemoState();
}

class _StackTraceDemoState extends State<StackTraceDemo> {
  String _stackTrace = '';

  void _captureStackTrace() {
    // Capture the native stack trace
    NativeStackTrace.capture().then((trace) {
      setState(() {
        _stackTrace = trace;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Native Stack Traces Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              onPressed: _captureStackTrace,
              child: Text('Capture Stack Trace'),
            ),
            SizedBox(height: 20),
            Text('Stack Trace:'),
            SizedBox(height: 10),
            Text(_stackTrace),
          ],
        ),
      ),
    );
  }
}
```

<!-- END_TUTORIAL -->

<!-- START_MAIN -->
# Complete Example of Using Native Stack Traces

```dart
import 'package:flutter/material.dart';
import 'package:native_stack_traces/native_stack_traces.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Native Stack Traces Demo',
      home: StackTraceDemo(),
    );
  }
}

class StackTraceDemo extends StatefulWidget {
  @override
  _StackTraceDemoState createState() => _StackTraceDemoState();
}

class _StackTraceDemoState extends State<StackTraceDemo> {
  String _stackTrace = ''; // Variable to hold the captured stack trace

  void _captureStackTrace() {
    // Capture the native stack trace
    NativeStackTrace.capture().then((trace) {
      setState(() {
        _stackTrace = trace; // Update the state with the captured trace
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Native Stack Traces Demo'), // App title
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              onPressed: _captureStackTrace, // Button to capture stack trace
              child: Text('Capture Stack Trace'),
            ),
            SizedBox(height: 20), // Space between button and text
            Text('Stack Trace:'),
            SizedBox(height: 10), // Space between label and stack trace
            Text(_stackTrace), // Display the captured stack trace
          ],
        ),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the main function, which runs the MyApp widget.
// 2. MyApp builds a MaterialApp with a title and home set to StackTraceDemo.
// 3. StackTraceDemo is a stateful widget that manages the state of the captured stack trace.
// 4. When the user presses the "Capture Stack Trace" button, the _captureStackTrace method is called.
// 5. This method uses the NativeStackTrace.capture() function to capture the native stack trace.
// 6. Once the trace is captured, the state is updated, and the UI reflects the new stack trace.
// 7. The captured stack trace is displayed on the screen for the user to view.
```
<!-- END_MAIN -->
```

This structured blog provides a comprehensive overview of the `native_stack_traces` Flutter package, including its description, setup tutorial, and a complete example with detailed comments explaining the application flow.