```markdown
<!-- START_DESCRIPTION -->
# Overview of the `connectivity_bloc` Flutter Package

The `connectivity_bloc` package is a powerful tool for managing network connectivity in Flutter applications using the BLoC (Business Logic Component) pattern. It allows developers to easily monitor and respond to changes in network connectivity, making it an essential package for applications that rely on internet access.

## When to Use This Package
You should consider using `connectivity_bloc` in scenarios where:
- Your application needs to handle network connectivity changes dynamically.
- You want to provide users with real-time feedback on their internet connection status.
- You are implementing features that require network access and need to manage offline scenarios gracefully.

## Key Features
- **Real-time Connectivity Monitoring**: Automatically detects changes in network status (Wi-Fi, mobile data, or no connection).
- **BLoC Architecture**: Leverages the BLoC pattern for better separation of concerns and easier testing.
- **Stream-based API**: Provides a stream of connectivity status updates that can be easily consumed by UI components.
- **Cross-Platform Support**: Works seamlessly on both Android and iOS platforms.

By utilizing `connectivity_bloc`, developers can create robust applications that handle connectivity issues gracefully, enhancing the overall user experience.
<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
# Tutorial: Setting Up and Using `connectivity_bloc`

## Installation
To get started with the `connectivity_bloc` package, you need to add it to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  connectivity_bloc: ^latest_version
```

Make sure to replace `^latest_version` with the most recent version available on [pub.dev](https://pub.dev/packages/connectivity_bloc).

## Platform-Specific Configuration

### Android
1. Open your `AndroidManifest.xml` file located at `android/app/src/main/AndroidManifest.xml`.
2. Add the following permissions to allow your app to access the internet and check network state:

```xml
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
```

### iOS
1. Open your `Info.plist` file located at `ios/Runner/Info.plist`.
2. Add the following key to request permission for network access:

```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```

## Using the Package
To use the `connectivity_bloc`, you need to create a BLoC that will manage the connectivity state. Hereâ€™s a simple example of how to set it up:

1. **Create a Connectivity BLoC**:

```dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:connectivity_bloc/connectivity_bloc.dart';

class ConnectivityCubit extends Cubit<ConnectivityState> {
  ConnectivityCubit() : super(ConnectivityInitial());

  void checkConnectivity() {
    // Logic to check connectivity and emit states
  }
}
```

2. **Integrate the BLoC into Your App**:

Wrap your main application widget with the `BlocProvider` to provide the connectivity state to the widget tree.

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

void main() {
  runApp(
    BlocProvider(
      create: (context) => ConnectivityCubit(),
      child: MyApp(),
    ),
  );
}
```

3. **Listen to Connectivity Changes**:

In your UI, you can listen to the connectivity state and update the interface accordingly.

```dart
BlocBuilder<ConnectivityCubit, ConnectivityState>(
  builder: (context, state) {
    if (state is ConnectivityConnected) {
      return Text('Connected to the Internet');
    } else if (state is ConnectivityDisconnected) {
      return Text('No Internet Connection');
    }
    return CircularProgressIndicator();
  },
);
```

With these steps, you can effectively manage network connectivity in your Flutter application using the `connectivity_bloc` package.
<!-- END_TUTORIAL -->

<!-- START_MAIN -->
# Complete Example of Using `connectivity_bloc`

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:connectivity_bloc/connectivity_bloc.dart';

// Main entry point of the application
void main() {
  runApp(
    BlocProvider(
      create: (context) => ConnectivityCubit(), // Providing the ConnectivityCubit to the widget tree
      child: MyApp(),
    ),
  );
}

// Main application widget
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Connectivity BLoC Example',
      home: ConnectivityScreen(), // Home screen of the app
    );
  }
}

// Screen to display connectivity status
class ConnectivityScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Connectivity BLoC Example'), // App bar title
      ),
      body: Center(
        child: BlocBuilder<ConnectivityCubit, ConnectivityState>(
          builder: (context, state) {
            // Listening to connectivity state changes
            if (state is ConnectivityConnected) {
              return Text('Connected to the Internet'); // Display when connected
            } else if (state is ConnectivityDisconnected) {
              return Text('No Internet Connection'); // Display when disconnected
            }
            return CircularProgressIndicator(); // Loading indicator while checking connectivity
          },
        ),
      ),
    );
  }
}

// ConnectivityCubit class to manage connectivity state
class ConnectivityCubit extends Cubit<ConnectivityState> {
  ConnectivityCubit() : super(ConnectivityInitial()) {
    // Initial state is set to ConnectivityInitial
    checkConnectivity(); // Check connectivity on initialization
  }

  void checkConnectivity() {
    // Logic to check connectivity and emit states
    // This is where you would implement the actual connectivity checking logic
    // For demonstration, we will emit a connected state after a delay
    Future.delayed(Duration(seconds: 2), () {
      emit(ConnectivityConnected()); // Emit connected state
    });
  }
}

// Connectivity states
abstract class ConnectivityState {}
class ConnectivityInitial extends ConnectivityState {}
class ConnectivityConnected extends ConnectivityState {}
class ConnectivityDisconnected extends ConnectivityState {}

// The application flow is as follows:
// 1. The app starts and the main function runs.
// 2. The BlocProvider creates an instance of ConnectivityCubit and provides it to the widget tree.
// 3. MyApp is built, which contains the ConnectivityScreen.
// 4. The ConnectivityScreen listens to the ConnectivityCubit for state changes.
// 5. On initialization, the ConnectivityCubit checks the connectivity status.
// 6. After a delay, it emits a ConnectivityConnected state, which updates the UI to show the connected message.
```
<!-- END_MAIN -->
```

### Summary
In this blog post, we explored the `connectivity_bloc` package, detailing its features, installation process, and usage. We provided a complete example of a Flutter application that demonstrates how to manage network connectivity using the BLoC pattern. The application flow was explained step-by-step through comments in the code, making it easier for developers to understand how to implement this package in their own projects.