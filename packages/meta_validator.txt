```markdown
<!-- START_DESCRIPTION -->
# Meta Validator: A Comprehensive Overview

The `meta_validator` Flutter package is designed to simplify the process of validating data in your Flutter applications. It provides a robust framework for defining validation rules and applying them to various data types, making it an essential tool for developers who want to ensure data integrity and user input validation.

## When to Use `meta_validator`

You should consider using `meta_validator` in scenarios such as:
- Form validation in user input fields (e.g., registration forms, login forms).
- Data validation for API requests to ensure that the data being sent is correct.
- Any situation where you need to enforce specific rules on data before processing it.

## Key Features

- **Declarative Validation**: Define validation rules in a clear and concise manner.
- **Custom Validators**: Create your own validation logic to meet specific requirements.
- **Error Handling**: Easily manage and display validation errors to users.
- **Integration**: Works seamlessly with Flutter's existing form widgets.

With these features, `meta_validator` helps streamline the validation process, allowing developers to focus on building their applications without worrying about the intricacies of data validation.

<!-- END_DESCRIPTION -->
```

```markdown
<!-- START_TUTORIAL -->
# Setting Up and Using `meta_validator`

## Installation

To add the `meta_validator` package to your Flutter project, include it in your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  meta_validator: ^latest_version
```

Replace `latest_version` with the most recent version available on [pub.dev](https://pub.dev/packages/meta_validator).

## Platform-Specific Configuration

### Android

For Android, ensure that your `minSdkVersion` is set to at least 21 in your `android/app/build.gradle` file:

```groovy
android {
    ...
    defaultConfig {
        ...
        minSdkVersion 21
        ...
    }
}
```

### iOS

For iOS, make sure to set the deployment target in your `ios/Podfile`:

```ruby
platform :ios, '10.0'
```

## Basic Usage

To use `meta_validator`, you need to create a validation model and apply it to your data. Hereâ€™s a simple example:

1. Import the package:

```dart
import 'package:meta_validator/meta_validator.dart';
```

2. Define your validation rules:

```dart
final validator = Validator()
  ..addRule('username', RequiredRule())
  ..addRule('email', EmailRule());
```

3. Validate your data:

```dart
final result = validator.validate({
  'username': 'JohnDoe',
  'email': 'john.doe@example.com',
});
```

4. Check for errors:

```dart
if (result.hasErrors) {
  print(result.errors);
}
```

This setup allows you to easily validate user input and handle errors effectively.

<!-- END_TUTORIAL -->
```

```markdown
<!-- START_MAIN -->
# Complete Example of `meta_validator`

```dart
import 'package:flutter/material.dart';
import 'package:meta_validator/meta_validator.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Meta Validator Example',
      home: ValidatorForm(),
    );
  }
}

class ValidatorForm extends StatefulWidget {
  @override
  _ValidatorFormState createState() => _ValidatorFormState();
}

class _ValidatorFormState extends State<ValidatorForm> {
  final _formKey = GlobalKey<FormState>();
  final _validator = Validator()
    ..addRule('username', RequiredRule())
    ..addRule('email', EmailRule());

  String? _username;
  String? _email;
  Map<String, List<String>>? _errors;

  void _validate() {
    // Validate the input data
    final result = _validator.validate({
      'username': _username,
      'email': _email,
    });

    // Check if there are any validation errors
    if (result.hasErrors) {
      setState(() {
        _errors = result.errors;
      });
    } else {
      // Proceed with the valid data
      print('Validation successful!');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Meta Validator Example'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              TextFormField(
                decoration: InputDecoration(labelText: 'Username'),
                onChanged: (value) {
                  _username = value;
                },
              ),
              TextFormField(
                decoration: InputDecoration(labelText: 'Email'),
                onChanged: (value) {
                  _email = value;
                },
              ),
              ElevatedButton(
                onPressed: _validate,
                child: Text('Submit'),
              ),
              // Display validation errors if any
              if (_errors != null) ...[
                for (var error in _errors!.entries)
                  Text('${error.key}: ${error.value.join(', ')}', style: TextStyle(color: Colors.red)),
              ],
            ],
          ),
        ),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the main function, which runs the RealFlutter widget.
// 2. RealFlutter builds a MaterialApp with a title and home set to ValidatorForm.
// 3. ValidatorForm is a stateful widget that manages the form state and validation logic.
// 4. The _validator object is created with rules for username and email.
// 5. When the user submits the form, the _validate method is called.
// 6. The input data is validated using the validator, and any errors are stored in the _errors variable.
// 7. If there are errors, they are displayed below the form fields.
// 8. If validation is successful, a success message is printed to the console.
```
<!-- END_MAIN -->
``` 

This structured approach provides a comprehensive understanding of the `meta_validator` package, guiding developers through its features, setup, and practical usage in a Flutter application.