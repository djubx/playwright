<-- START_DESCRIPTION -->

Riverpod Repo Flutter Package
=============================

The `riverpod_repo` package is a state management library for Flutter that allows you to manage your app's state in a predictable and scalable way. It is built on top of the popular Riverpod library and provides a simple and intuitive API for managing your app's state.

When to Use Riverpod Repo
-------------------------

You should use `riverpod_repo` when you need to manage complex state in your Flutter app. This can include things like:

* Managing a list of items that need to be updated in real-time
* Handling errors and loading states in a predictable way
* Sharing state between multiple widgets in your app

Features
--------

* Predictable and scalable state management
* Simple and intuitive API
* Support for handling errors and loading states
* Works well with other Riverpod libraries and tools

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

Setting Up Riverpod Repo
-------------------------

To use `riverpod_repo` in your Flutter app, you will need to add it to your `pubspec.yaml` file:

```yml
dependencies:
  flutter:
    sdk: flutter
  riverpod_repo: ^1.0.0
```

Next, you will need to import the `riverpod_repo` library in your Dart file:

```dart
import 'package:riverpod_repo/riverpod_repo.dart';
```

Creating a Repository
---------------------

To use `riverpod_repo`, you will need to create a repository class that extends the `Repository` class:

```dart
class MyRepository extends Repository {
  @override
  Future<List<MyModel>> fetch() async {
    // Fetch data from API or database
  }
}
```

Using the Repository
--------------------

To use the repository, you will need to create a `Provider` that wraps the repository:

```dart
final myRepositoryProvider = Provider((ref) => MyRepository());
```

You can then use the `Provider` to access the repository in your widgets:

```dart
class MyWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final myRepository = ref.watch(myRepositoryProvider);
    return FutureBuilder(
      future: myRepository.fetch(),
      builder: (context, snapshot) {
        if (snapshot.hasData) {
          return ListView.builder(
            itemCount: snapshot.data.length,
            itemBuilder: (context, index) {
              return ListTile(
                title: Text(snapshot.data[index].name),
              );
            },
          );
        } else {
          return Center(
            child: CircularProgressIndicator(),
          );
        }
      },
    );
  }
}
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:riverpod_repo/riverpod_repo.dart';

void main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Riverpod Repo Example',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1. Create a provider that wraps the repository
    final myRepositoryProvider = Provider((ref) => MyRepository());
    
    // 2. Use the provider to access the repository
    final myRepository = ref.watch(myRepositoryProvider);
    
    // 3. Use the repository to fetch data
    return FutureBuilder(
      future: myRepository.fetch(),
      builder: (context, snapshot) {
        // 4. Handle the loading state
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Center(
            child: CircularProgressIndicator(),
          );
        }
        
        // 5. Handle the error state
        if (snapshot.hasError) {
          return Center(
            child: Text('Error: ${snapshot.error}'),
          );
        }
        
        // 6. Handle the data state
        if (snapshot.hasData) {
          return ListView.builder(
            itemCount: snapshot.data.length,
            itemBuilder: (context, index) {
              return ListTile(
                title: Text(snapshot.data[index].name),
              );
            },
          );
        }
        
        // 7. Handle the empty state
        return Center(
          child: Text('No data available'),
        );
      },
    );
  }
}

class MyRepository extends Repository {
  @override
  Future<List<MyModel>> fetch() async {
    // Fetch data from API or database
    return [
      MyModel('Item 1'),
      MyModel('Item 2'),
      MyModel('Item 3'),
    ];
  }
}

class MyModel {
  final String name;
  
  MyModel(this.name);
}

// The application flow is as follows:
// 1. The user opens the app and the `MyApp` widget is built.
// 2. The `MyApp` widget creates a `ProviderScope` that wraps the entire app.
// 3. The `MyHomePage` widget is built and it creates a provider that wraps the `MyRepository`.
// 4. The `MyHomePage` widget uses the provider to access the `MyRepository`.
// 5. The `MyHomePage` widget uses the `MyRepository` to fetch data.
// 6. The `MyHomePage` widget handles the loading state by displaying a `CircularProgressIndicator`.
// 7. The `MyHomePage` widget handles the error state by displaying an error message.
// 8. The `MyHomePage` widget handles the data state by displaying a `ListView` of items.
// 9. The `MyHomePage` widget handles the empty state by displaying a message indicating that no data is available.
```

<-- END_MAIN -->