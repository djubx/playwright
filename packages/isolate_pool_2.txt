<-- START_DESCRIPTION -->

# Isolate Pool 2: A High-Performance Isolate Management Package for Flutter
===========================================================

Isolate Pool 2 is a powerful Flutter package designed to simplify the process of working with isolates in Flutter applications. It provides a high-performance isolate management system that allows developers to execute tasks in parallel, improving overall app performance and responsiveness.

## When to Use Isolate Pool 2

Isolate Pool 2 is ideal for tasks that require intense computations, such as:

* Image processing
* Data compression
* Network requests
* Database operations

By offloading these tasks to separate isolates, you can keep your app's UI thread free from heavy computations, ensuring a smooth user experience.

## Key Features

*   **Isolate Management**: Create and manage multiple isolates with ease.
*   **Task Execution**: Execute tasks in parallel across multiple isolates.
*   **Isolate Communication**: Send and receive messages between isolates.
*   **Error Handling**: Catch and handle errors that occur within isolates.

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up Isolate Pool 2

To use Isolate Pool 2 in your Flutter project, follow these steps:

### Step 1: Add the Package to Your `pubspec.yaml` File

```yml
dependencies:
  isolate_pool_2: ^1.0.0
```

### Step 2: Import the Package in Your Dart File

```dart
import 'package(isolate_pool_2/isolate_pool_2.dart';
```

### Step 3: Create an Isolate Pool

```dart
final isolatePool = IsolatePool();
```

### Step 4: Create an Isolate

```dart
final isolate = await isolatePool.createIsolate();
```

### Step 5: Execute a Task in the Isolate

```dart
final result = await isolate.execute(() {
  // Your task code here
});
```

### Step 6: Send and Receive Messages Between Isolates

```dart
// Send a message to the isolate
isolate.send('Hello, isolate!');

// Receive a message from the isolate
final message = await isolate.receive();
```

### Step 7: Catch and Handle Errors

```dart
try {
  // Your code here
} catch (error) {
  // Handle the error
}
```

### Platform-Specific Details

*   **Android**: No additional setup required.
*   **iOS**: No additional setup required.

### Required Configurations or Optimizations

*   **Isolate Count**: You can adjust the number of isolates created by the pool by passing the `isolateCount` parameter to the `IsolatePool` constructor.

```dart
final isolatePool = IsolatePool(isolateCount: 5);
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package(isolate_pool_2/isolate_pool_2.dart';

void main() {
  runApp(const RealFlutterApp());
}

class RealFlutterApp extends StatelessWidget {
  const RealFlutterApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: const RealFlutterHomePage(),
    );
  }
}

class RealFlutterHomePage extends StatefulWidget {
  const RealFlutterHomePage({Key? key}) : super(key: key);

  @override
  State<RealFlutterHomePage> createState() => _RealFlutterHomePageState();
}

class _RealFlutterHomePageState extends State<RealFlutterHomePage> {
  final _isolatePool = IsolatePool();
  final _textController = TextEditingController();
  String _result = '';

  @override
  void initState() {
    super.initState();
    _initIsolate();
  }

  Future<void> _initIsolate() async {
    // Create an isolate
    final isolate = await _isolatePool.createIsolate();

    // Send a message to the isolate
    isolate.send('Hello, isolate!');

    // Receive a message from the isolate
    final message = await isolate.receive();

    // Update the UI with the received message
    setState(() {
      _result = message;
    });
  }

  Future<void> _executeTask() async {
    // Create an isolate
    final isolate = await _isolatePool.createIsolate();

    // Execute a task in the isolate
    final result = await isolate.execute(() {
      // Simulate a heavy computation
      return 'Task result';
    });

    // Update the UI with the task result
    setState(() {
      _result = result;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Isolate Pool 2 Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(_result),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _executeTask,
              child: const Text('Execute Task'),
            ),
          ],
        ),
      ),
    );
  }
}

// The application flow:
// 1. The app starts and creates an IsolatePool instance.
// 2. The app creates an isolate using the IsolatePool instance.
// 3. The app sends a message to the isolate.
// 4. The app receives a message from the isolate and updates the UI.
// 5. When the user clicks the "Execute Task" button, the app executes a task in the isolate.
// 6. The app receives the task result and updates the UI.

// Summary: The app demonstrates how to use Isolate Pool 2 to create and manage isolates, send and receive messages between isolates, and execute tasks in isolates. The app also shows how to update the UI with the received messages and task results.

```

<-- END_MAIN -->