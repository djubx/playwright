<-- START_DESCRIPTION -->

# Flux Validator Dart Package
The `flux_validator_dart` package is a simple and easy-to-use validation library for Flutter applications. It provides a set of pre-built validation rules that can be used to validate user input, such as email addresses, phone numbers, passwords, and more.

## When to Use
This package is useful when you need to validate user input in your Flutter application. For example, you can use it to validate:

* Email addresses
* Phone numbers
* Passwords
* Credit card numbers
* Dates

## Features
The `flux_validator_dart` package provides the following features:

* Pre-built validation rules for common input types
* Customizable validation rules
* Support for multiple validation rules per field
* Error messages for each validation rule

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up the Package
To use the `flux_validator_dart` package, you need to add it to your `pubspec.yaml` file:

```yml
dependencies:
  flux_validator_dart: ^1.0.0
```

Then, run `flutter pub get` to install the package.

## Using the Package
To use the package, you need to import it in your Dart file:

```dart
import 'package:flux_validator_dart/flux_validator_dart.dart';
```

You can then use the `Validator` class to validate user input:

```dart
Validator validator = Validator(
  rules: {
    'email': [Required(), Email()],
    'password': [Required(), MinLength(8)],
  },
);

// Validate user input
Map<String, dynamic> userInput = {
  'email': 'example@example.com',
  'password': 'password123',
};

Map<String, String> errors = validator.validate(userInput);

// Check if there are any errors
if (errors.isNotEmpty) {
  // Handle errors
} else {
  // User input is valid
}
```

### Platform-Specific Details
The `flux_validator_dart` package works on both Android and iOS platforms. However, you may need to configure the package differently depending on the platform.

For example, on Android, you may need to add the following configuration to your `AndroidManifest.xml` file:

```xml
<application
  ...
  android:hardwareAccelerated="true"
  ...
>
```

On iOS, you may need to add the following configuration to your `Info.plist` file:

```xml
<key>NSAppTransportSecurity</key>
<dict>
  <key>NSAllowsArbitraryLoads</key>
  <true/>
</dict>
```

### Optimizations
To optimize the performance of the `flux_validator_dart` package, you can use the following techniques:

* Use the `Validator` class to validate multiple fields at once.
* Use the `rules` property to define multiple validation rules for each field.
* Use the `errorMessages` property to define custom error messages for each validation rule.

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:flux_validator_dart/flux_validator_dart.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flux Validator Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Flux Validator Demo'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              TextFormField(
                controller: _emailController,
                decoration: InputDecoration(
                  labelText: 'Email',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  // Use the Email validation rule
                  return Validator(
                    rules: [Required(), Email()],
                  ).validate({'email': value})['email'];
                },
              ),
              SizedBox(height: 16),
              TextFormField(
                controller: _passwordController,
                decoration: InputDecoration(
                  labelText: 'Password',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  // Use the MinLength validation rule
                  return Validator(
                    rules: [Required(), MinLength(8)],
                  ).validate({'password': value})['password'];
                },
              ),
              SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  if (_formKey.currentState.validate()) {
                    // User input is valid
                    print('Email: ${_emailController.text}');
                    print('Password: ${_passwordController.text}');
                  }
                },
                child: Text('Submit'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// The application flow is as follows:
// 1. The user enters their email and password in the text fields.
// 2. When the user clicks the submit button, the form is validated using the _formKey.currentState.validate() method.
// 3. The validate() method checks if the email and password fields are valid using the Validator class.
// 4. If the fields are valid, the user input is printed to the console.
// 5. If the fields are not valid, an error message is displayed below the text field.

// In summary, the code flows as follows:
// User input -> Form validation -> Validator class -> Validation rules -> Error messages
```

<-- END_MAIN -->