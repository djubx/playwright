# Understanding the `app_versioning` Flutter Package

## <-- START_DESCRIPTION -->

### Description

The `app_versioning` package is a Flutter plugin that allows developers to manage and display the versioning of their applications easily. It provides a straightforward way to retrieve the current version of the app, check for updates, and manage versioning across different platforms. This package is particularly useful for applications that require version control, such as those that need to notify users about updates or maintain compatibility with backend services.

#### Key Features:
- **Retrieve App Version**: Easily fetch the current version of your app.
- **Platform Support**: Works seamlessly on both Android and iOS.
- **Version Comparison**: Compare the current version with a specified version to determine if an update is needed.
- **User Notifications**: Notify users about available updates based on version checks.

#### When to Use:
- When you want to inform users about new updates.
- For applications that require version checks before performing certain actions.
- To maintain compatibility with backend services that may have version-specific requirements.

## <-- END_DESCRIPTION -->

## <-- START_TUTORIAL -->

### Tutorial

#### Installation

To use the `app_versioning` package, you need to add it to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  app_versioning: ^1.0.0  # Check for the latest version on pub.dev
```

After adding the dependency, run `flutter pub get` to install the package.

#### Platform-Specific Configuration

**For Android:**
1. Ensure that your `minSdkVersion` is set to at least 21 in your `android/app/build.gradle` file:

   ```groovy
   android {
       ...
       defaultConfig {
           ...
           minSdkVersion 21
           ...
       }
   }
   ```

**For iOS:**
1. Open your `ios/Runner/Info.plist` file and ensure that the versioning keys are set correctly. You may need to add the following keys if they are not present:

   ```xml
   <key>CFBundleShortVersionString</key>
   <string>1.0</string>
   <key>CFBundleVersion</key>
   <string>1</string>
   ```

#### Usage

To use the `app_versioning` package, you can follow these steps:

1. Import the package in your Dart file:

   ```dart
   import 'package:app_versioning/app_versioning.dart';
   ```

2. Create a method to check the app version:

   ```dart
   Future<void> checkAppVersion() async {
       String currentVersion = await AppVersioning.getVersion();
       print("Current App Version: $currentVersion");
   }
   ```

3. Compare the current version with a new version:

   ```dart
   Future<void> compareVersion(String newVersion) async {
       String currentVersion = await AppVersioning.getVersion();
       if (currentVersion != newVersion) {
           print("Update Available: $newVersion");
       } else {
           print("You are on the latest version.");
       }
   }
   ```

## <-- END_TUTORIAL -->

## <-- START_MAIN -->

### Complete Example

```dart
import 'package:flutter/material.dart';
import 'package:app_versioning/app_versioning.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'App Versioning Example',
      home: VersionCheckScreen(),
    );
  }
}

class VersionCheckScreen extends StatefulWidget {
  @override
  _VersionCheckScreenState createState() => _VersionCheckScreenState();
}

class _VersionCheckScreenState extends State<VersionCheckScreen> {
  String _currentVersion = "Fetching...";
  String _updateMessage = "";

  @override
  void initState() {
    super.initState();
    _checkAppVersion();
  }

  Future<void> _checkAppVersion() async {
    // Fetch the current app version
    String currentVersion = await AppVersioning.getVersion();
    setState(() {
      _currentVersion = currentVersion; // Update the state with the current version
    });

    // Compare with a hypothetical new version
    String newVersion = "1.1.0"; // This could be fetched from a server
    if (currentVersion != newVersion) {
      setState(() {
        _updateMessage = "Update Available: $newVersion"; // Notify user about the update
      });
    } else {
      setState(() {
        _updateMessage = "You are on the latest version."; // Notify user they are up to date
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('App Versioning Example'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text('Current App Version: $_currentVersion'), // Display current version
            SizedBox(height: 20),
            Text(_updateMessage), // Display update message
          ],
        ),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the main function, which runs the RealFlutter widget.
// 2. RealFlutter builds a MaterialApp with a title and a home screen (VersionCheckScreen).
// 3. In the VersionCheckScreen, the current app version is fetched in the initState method.
// 4. The _checkAppVersion method retrieves the current version and compares it with a hypothetical new version.
// 5. Based on the comparison, it updates the UI to inform the user whether an update is available or if they are on the latest version.
```

## <-- END_MAIN -->

### Summary

In this blog post, we explored the `app_versioning` Flutter package, which simplifies the process of managing app versions. We covered the installation process, platform-specific configurations, and provided a complete example demonstrating how to check the current app version and notify users about available updates. This package is particularly useful for applications that require version control and user notifications regarding updates. By following the provided example, developers can easily integrate versioning into their Flutter applications.