```markdown
<-- START_DESCRIPTION -->

# Understanding the `go_router_builder` Flutter Package

The `go_router_builder` package is a powerful tool for Flutter developers looking to implement navigation in their applications. It builds on top of the `go_router` package, providing a more structured and scalable approach to managing routes in a Flutter app. This package is particularly useful for large applications where navigation can become complex and difficult to manage.

## When to Use `go_router_builder`

- **Complex Navigation**: If your application has a complex navigation structure with nested routes, `go_router_builder` can help manage this complexity.
- **Scalability**: As your application grows, maintaining a clean and organized routing structure is crucial. This package helps in keeping the routing logic separate and modular.
- **Type Safety**: It provides type-safe routing, reducing runtime errors related to navigation.

## Key Features

- **Code Generation**: Automatically generates route definitions, reducing boilerplate code.
- **Type Safety**: Ensures that routes are type-safe, catching errors at compile time.
- **Nested Routing**: Supports nested routes, making it easier to manage complex navigation hierarchies.
- **Deep Linking**: Facilitates deep linking, allowing users to navigate directly to specific parts of the app.

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up and Using `go_router_builder`

In this section, we'll walk through the setup process for the `go_router_builder` package and demonstrate how to integrate it into a Flutter project.

## Setup Process

1. **Add Dependencies**: First, add the `go_router_builder` package to your `pubspec.yaml` file.

   ```yaml
   dependencies:
     flutter:
       sdk: flutter
     go_router: ^5.0.0
     go_router_builder: ^1.0.0
   ```

2. **Install Packages**: Run `flutter pub get` to install the new dependencies.

3. **Configure Code Generation**: Create a `build.yaml` file in the root of your project to configure code generation.

   ```yaml
   targets:
     $default:
       builders:
         go_router_builder:
           options:
             output: lib/routes.g.dart
   ```

4. **Define Routes**: Create a Dart file to define your routes using annotations provided by `go_router_builder`.

   ```dart
   import 'package:go_router_builder/go_router_builder.dart';

   @GoRoute(path: '/', name: 'home')
   void homeRoute() {}

   @GoRoute(path: '/details', name: 'details')
   void detailsRoute() {}
   ```

5. **Generate Code**: Run the build runner to generate the routing code.

   ```bash
   flutter pub run build_runner build
   ```

## Platform-Specific Details

- **Android**: Ensure that your `AndroidManifest.xml` is configured for deep linking if you plan to use this feature.
- **iOS**: Update your `Info.plist` to handle universal links for deep linking.

## Optimizations

- **Lazy Loading**: Use lazy loading for routes that are not immediately needed to improve performance.
- **Route Guards**: Implement route guards to protect certain routes based on user authentication or other conditions.

<-- END_TUTORIAL -->

<-- START_MAIN -->

# Complete Example of Using `go_router_builder`

Below is a complete example of a Flutter application using the `go_router_builder` package. This example demonstrates setting up routes, navigating between them, and handling deep links.

```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'routes.g.dart'; // Generated file

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  // Initialize the GoRouter with the generated routes
  final GoRouter _router = GoRouter(
    routes: $appRoutes, // Use the generated routes
  );

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerConfig: _router, // Set the router configuration
      title: 'RealFlutter App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
    );
  }
}

// Home screen widget
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Home'),
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Navigate to the details screen
            context.go('/details');
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}

// Details screen widget
class DetailsScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Details'),
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Navigate back to the home screen
            context.go('/');
          },
          child: Text('Back to Home'),
        ),
      ),
    );
  }
}

// Application Flow Explanation
// 1. The application starts with the `RealFlutter` widget, which sets up the `GoRouter` with generated routes.
// 2. The `MaterialApp.router` is configured with the router, enabling navigation based on the defined routes.
// 3. The `HomeScreen` is the initial screen, displaying a button to navigate to the `DetailsScreen`.
// 4. When the button on the `HomeScreen` is pressed, the app navigates to the `DetailsScreen` using `context.go('/details')`.
// 5. The `DetailsScreen` provides a button to navigate back to the `HomeScreen`, demonstrating bidirectional navigation.
// 6. The routing logic is managed by the `go_router_builder`, which generates the necessary code for handling routes.

```

<-- END_MAIN -->
```

This blog post provides a comprehensive guide to using the `go_router_builder` package in Flutter, from setup to a complete example. By following these steps, developers can efficiently manage complex navigation structures in their Flutter applications.