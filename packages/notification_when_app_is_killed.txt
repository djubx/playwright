```markdown
<!-- START_DESCRIPTION -->
# Notification When App is Killed Flutter Package

The `notification_when_app_is_killed` package is a powerful tool for Flutter developers looking to manage notifications effectively, even when the app is not running. This package allows you to handle notifications that are triggered while the app is in the background or completely killed. 

## When to Use This Package
- **Background Notifications**: If your app needs to respond to notifications while it is not actively running, this package is essential.
- **User Engagement**: Keep users engaged by sending timely notifications that can bring them back to the app.
- **Task Reminders**: Perfect for applications that require reminders or alerts, such as to-do lists or calendar apps.

## Features
- **Foreground and Background Handling**: Manage notifications seamlessly whether the app is in the foreground, background, or killed.
- **Custom Notification Payloads**: Send custom data with notifications to handle specific actions when the user interacts with them.
- **Cross-Platform Support**: Works on both Android and iOS, ensuring a consistent experience across devices.

This package is particularly useful for applications that rely on timely updates and user engagement through notifications.
<!-- END_DESCRIPTION -->
```

```markdown
<!-- START_TUTORIAL -->
# Tutorial: Setting Up and Using Notification When App is Killed

## Installation
To get started with the `notification_when_app_is_killed` package, add it to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  notification_when_app_is_killed: ^latest_version
```

Make sure to replace `^latest_version` with the most recent version available on [pub.dev](https://pub.dev/packages/notification_when_app_is_killed).

## Platform-Specific Configuration

### Android
1. **Permissions**: Ensure you have the necessary permissions in your `AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
<uses-permission android:name="android.permission.VIBRATE"/>
```

2. **Service Declaration**: Add the service to handle notifications:

```xml
<service android:name="com.example.notification_when_app_is_killed.NotificationService"/>
```

### iOS
1. **Permissions**: Request notification permissions in your app. Update your `Info.plist`:

```xml
<key>UIBackgroundModes</key>
<array>
    <string>fetch</string>
    <string>remote-notification</string>
</array>
<key>NSUserNotificationUsageDescription</key>
<string>We use notifications to keep you updated.</string>
```

2. **Request Permission**: In your Dart code, request permission to show notifications:

```dart
import 'package:notification_when_app_is_killed/notification_when_app_is_killed.dart';

void requestPermission() async {
  await NotificationWhenAppIsKilled.requestPermission();
}
```

## Using the Package
To utilize the package, initialize it in your main application file:

```dart
import 'package:flutter/material.dart';
import 'package:notification_when_app_is_killed/notification_when_app_is_killed.dart';

void main() {
  runApp(MyApp());
  NotificationWhenAppIsKilled.initialize();
}
```

You can then set up notification listeners and handle incoming notifications:

```dart
NotificationWhenAppIsKilled.onNotificationReceived.listen((notification) {
  // Handle the notification
  print("Notification received: ${notification.title}");
});
```

This setup allows your app to respond to notifications even when it is not running, ensuring a seamless user experience.
<!-- END_TUTORIAL -->
```

```markdown
<!-- START_MAIN -->
# Complete Example of Notification When App is Killed

```dart
import 'package:flutter/material.dart';
import 'package:notification_when_app_is_killed/notification_when_app_is_killed.dart';

void main() {
  runApp(RealFlutter());
  // Initialize the notification handling
  NotificationWhenAppIsKilled.initialize();
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Notification Example',
      home: NotificationHome(),
    );
  }
}

class NotificationHome extends StatefulWidget {
  @override
  _NotificationHomeState createState() => _NotificationHomeState();
}

class _NotificationHomeState extends State<NotificationHome> {
  @override
  void initState() {
    super.initState();
    // Listen for notifications when the app is in the background or killed
    NotificationWhenAppIsKilled.onNotificationReceived.listen((notification) {
      // Display a dialog when a notification is received
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(notification.title),
          content: Text(notification.body),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text('OK'),
            ),
          ],
        ),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Notification Example'),
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Simulate sending a notification
            NotificationWhenAppIsKilled.showNotification(
              title: 'Hello!',
              body: 'This is a test notification.',
            );
          },
          child: Text('Send Notification'),
        ),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts and initializes the notification handling.
// 2. The NotificationHome widget listens for incoming notifications.
// 3. When a notification is received, an AlertDialog is displayed with the notification's title and body.
// 4. The user can dismiss the dialog by pressing the 'OK' button.
// 5. The user can send a test notification by pressing the 'Send Notification' button, which triggers the showNotification method.
```
<!-- END_MAIN -->
``` 

This structured approach provides a comprehensive overview of the `notification_when_app_is_killed` package, guiding developers through its features, setup, and practical usage in a Flutter application.