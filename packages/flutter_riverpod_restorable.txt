```markdown
<!-- START_DESCRIPTION -->
# flutter_riverpod_restorable: A Comprehensive Overview

The `flutter_riverpod_restorable` package is an extension of the popular Riverpod state management solution, designed to provide a seamless way to manage state that can be restored across app sessions. This package is particularly useful for applications that require state persistence, such as form data, user preferences, or any other data that should remain consistent even after the app is closed and reopened.

## When to Use This Package
- **State Persistence**: When you need to maintain the state of your application across sessions.
- **Complex State Management**: For applications with complex state requirements that benefit from Riverpod's architecture.
- **User Experience**: To enhance user experience by preserving user inputs and selections.

## Key Features
- **Integration with Riverpod**: Leverages Riverpod's powerful state management capabilities.
- **Restorable State**: Automatically saves and restores state when the app is restarted.
- **Easy to Use**: Simple API that integrates seamlessly with existing Riverpod providers.
- **Support for Multiple Platforms**: Works on both Android and iOS, ensuring a consistent experience across devices.

Overall, `flutter_riverpod_restorable` is an excellent choice for Flutter developers looking to implement robust state management with persistence capabilities.
<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
# Tutorial: Setting Up and Using flutter_riverpod_restorable

In this tutorial, we will walk through the setup process for the `flutter_riverpod_restorable` package and demonstrate how to use it in a Flutter application.

## Step 1: Adding the Package to Your Project
To get started, you need to add the `flutter_riverpod_restorable` package to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod_restorable: ^latest_version
```

Make sure to replace `^latest_version` with the latest version available on [pub.dev](https://pub.dev/packages/flutter_riverpod_restorable).

## Step 2: Platform-Specific Configuration
### Android
For Android, ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 21:

```groovy
android {
    ...
    defaultConfig {
        ...
        minSdkVersion 21
    }
}
```

### iOS
For iOS, you may need to enable state restoration in your `Info.plist`:

```xml
<key>UIApplicationSupportsIndirectInputEvents</key>
<true/>
```

## Step 3: Using the Package
Now that we have set up the package, let's create a simple application that demonstrates its usage.

1. Create a `StateNotifier` to manage the state.
2. Use `RestorableProvider` to make the state restorable.
3. Build a simple UI to interact with the state.

This will be demonstrated in the next section with a complete example.
<!-- END_TUTORIAL -->

<!-- START_MAIN -->
# Complete Example of flutter_riverpod_restorable

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod_restorable/flutter_riverpod_restorable.dart';

// Define a StateNotifier to manage the state
class CounterNotifier extends StateNotifier<int> {
  CounterNotifier() : super(0); // Initialize state to 0

  void increment() => state++; // Increment the counter
}

// Create a RestorableProvider for the CounterNotifier
final counterProvider = StateNotifierProvider.autoDispose<CounterNotifier, int>(
  (ref) => CounterNotifier(),
);

// Main function to run the app
void main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}

// Define the main application widget
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Riverpod Restorable Example',
      home: CounterScreen(),
    );
  }
}

// Create a screen to display and interact with the counter
class CounterScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Use the counterProvider to get the current counter value
    final counter = ref.watch(counterProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text('Counter with Riverpod Restorable'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text(
              'Counter Value:',
            ),
            Text(
              '$counter', // Display the current counter value
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          ref.read(counterProvider.notifier).increment(); // Increment the counter on button press
        },
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ),
    );
  }
}

// The following comments explain the flow of the application:
// 1. The app starts with the main function, which initializes the ProviderScope.
// 2. MyApp is the root widget that sets up the MaterialApp.
// 3. CounterScreen is displayed as the home screen, where the counter value is shown.
// 4. The CounterNotifier manages the state of the counter, starting at 0.
// 5. The user can increment the counter by pressing the FloatingActionButton.
// 6. The counter value is displayed in the center of the screen and updates in real-time.
```
<!-- END_MAIN -->
```

### Summary of Application Flow
The application initializes with a counter set to zero. The user can increment the counter by pressing the floating action button, which triggers the `increment` method in the `CounterNotifier`. The updated counter value is displayed on the screen, demonstrating the state management capabilities of the `flutter_riverpod_restorable` package. This simple example showcases how to integrate state restoration with Riverpod, providing a solid foundation for more complex applications.