<-- START_DESCRIPTION -->

Nested Scroll Views in Flutter
==============================

The `nested_scroll_views` package in Flutter allows you to create a scrolling view that can be nested inside another scrolling view. This is useful when you want to create a complex scrolling layout, such as a scrolling list inside a scrolling page.

When to Use
------------

You should use this package when you need to create a scrolling layout that contains multiple scrolling views. For example:

* A scrolling page that contains a scrolling list
* A scrolling list that contains scrolling items
* A scrolling view that contains multiple scrolling views

Features
--------

The `nested_scroll_views` package provides the following features:

* Support for nested scrolling views
* Customizable scrolling behavior
* Support for multiple scrolling views

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

Setting Up the Package
------------------------

To use the `nested_scroll_views` package, you need to add it to your `pubspec.yaml` file:

```yml
dependencies:
  flutter:
    sdk: flutter
  nested_scroll_views: ^1.0.0
```

Then, run `flutter pub get` to install the package.

Using the Package
-----------------

To use the package, you need to import it in your Dart file:

```dart
import 'package:nested_scroll_views/nested_scroll_views.dart';
```

Then, you can use the `NestedScrollView` widget to create a scrolling view that can be nested inside another scrolling view:

```dart
NestedScrollView(
  headerSliverBuilder: (context, innerBoxIsScrolled) {
    return SliverAppBar(
      title: Text('Nested Scroll Views'),
    );
  },
  body: ListView.builder(
    itemCount: 100,
    itemBuilder: (context, index) {
      return ListTile(
        title: Text('Item $index'),
      );
    },
  ),
)
```

Platform-Specific Details
-------------------------

The `nested_scroll_views` package works on both Android and iOS platforms. However, there are some platform-specific details to consider:

* On Android, the `NestedScrollView` widget uses the `android.widget.NestedScrollView` class to create a scrolling view.
* On iOS, the `NestedScrollView` widget uses the `UIScrollView` class to create a scrolling view.

Configurations and Optimizations
---------------------------------

To optimize the performance of the `NestedScrollView` widget, you can use the following configurations:

* `cacheExtent`: This property determines the number of pixels to cache before and after the visible area of the scrolling view.
* `physics`: This property determines the scrolling behavior of the scrolling view.

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:nested_scroll_views/nested_scroll_views.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Nested Scroll Views',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: NestedScrollView(
        // Create a header sliver that contains a scrolling app bar
        headerSliverBuilder: (context, innerBoxIsScrolled) {
          return SliverAppBar(
            title: Text('Nested Scroll Views'),
            // Make the app bar scrollable
            floating: true,
            // Make the app bar snap to the top of the screen
            snap: true,
          );
        },
        // Create a scrolling body that contains a list view
        body: ListView.builder(
          // Create 100 list items
          itemCount: 100,
          itemBuilder: (context, index) {
            return ListTile(
              title: Text('Item $index'),
            );
          },
        ),
      ),
    );
  }
}

// The application flow is as follows:
// 1. The user scrolls the list view, which causes the app bar to scroll off the screen.
// 2. When the user reaches the top of the list view, the app bar snaps back into place.
// 3. The user can then scroll the app bar to reveal the list view.
// 4. The list view is scrollable, and the user can scroll it independently of the app bar.
// 5. The app bar and list view are both scrollable, and the user can scroll them simultaneously.

// In summary, the code creates a scrolling app bar and a scrolling list view, and allows the user to scroll them independently or simultaneously.
```

<-- END_MAIN -->