# Understanding the `redux_compact` Flutter Package

## <-- START_DESCRIPTION -->

### Overview of `redux_compact`

The `redux_compact` package is a lightweight implementation of the Redux pattern for state management in Flutter applications. It simplifies the process of managing application state by providing a clear structure and predictable state transitions. This package is particularly useful for developers who prefer a functional programming approach and want to maintain a unidirectional data flow in their applications.

### When to Use `redux_compact`

You might consider using `redux_compact` in scenarios such as:

- **Complex State Management**: When your application has a complex state that needs to be shared across multiple widgets.
- **Predictable State Changes**: If you want to ensure that state changes are predictable and traceable, making debugging easier.
- **Separation of Concerns**: When you want to separate your UI code from business logic, enhancing maintainability.

### Key Features

- **Compact API**: A simplified API that reduces boilerplate code compared to traditional Redux implementations.
- **Middleware Support**: Ability to add middleware for handling side effects, logging, and more.
- **Immutable State**: Encourages the use of immutable state, which can help prevent unintended side effects.
- **DevTools Integration**: Supports integration with Redux DevTools for time-travel debugging.

## <-- END_DESCRIPTION -->

## <-- START_TUTORIAL -->

### Setting Up `redux_compact`

To get started with `redux_compact`, follow these steps:

1. **Add Dependency**: Open your `pubspec.yaml` file and add the `redux_compact` package:

   ```yaml
   dependencies:
     flutter:
       sdk: flutter
     redux_compact: ^latest_version
   ```

   Replace `^latest_version` with the latest version available on [pub.dev](https://pub.dev/packages/redux_compact).

2. **Install Packages**: Run the following command in your terminal to install the package:

   ```bash
   flutter pub get
   ```

3. **Platform-Specific Configuration**:
   - **Android**: Ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 21.
   - **iOS**: No specific configurations are required, but ensure you have the latest version of Xcode.

### Basic Usage

1. **Create a Store**: Define your application state and actions.

   ```dart
   import 'package:redux_compact/redux_compact.dart';

   // Define the application state
   class AppState {
     final int counter;

     AppState({this.counter = 0});
   }

   // Define actions
   class IncrementAction {}
   class DecrementAction {}
   ```

2. **Create a Reducer**: Implement a reducer function to handle state changes.

   ```dart
   AppState appReducer(AppState state, dynamic action) {
     if (action is IncrementAction) {
       return AppState(counter: state.counter + 1);
     } else if (action is DecrementAction) {
       return AppState(counter: state.counter - 1);
     }
     return state;
   }
   ```

3. **Set Up the Store**: Initialize the store in your main application file.

   ```dart
   final store = Store<AppState>(appReducer, initialState: AppState());
   ```

4. **Connect to the UI**: Use the `StoreProvider` to provide the store to your widget tree.

   ```dart
   import 'package:flutter/material.dart';
   import 'package:redux_compact/redux_compact.dart';

   void main() {
     runApp(StoreProvider<AppState>(
       store: store,
       child: MyApp(),
     ));
   }
   ```

## <-- END_TUTORIAL -->

## <-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:redux_compact/redux_compact.dart';

// Define the application state
class AppState {
  final int counter;

  AppState({this.counter = 0});
}

// Define actions
class IncrementAction {}
class DecrementAction {}

// Reducer function to handle state changes
AppState appReducer(AppState state, dynamic action) {
  if (action is IncrementAction) {
    return AppState(counter: state.counter + 1); // Increment counter
  } else if (action is DecrementAction) {
    return AppState(counter: state.counter - 1); // Decrement counter
  }
  return state; // Return current state if no action matches
}

// Main function to run the app
void main() {
  final store = Store<AppState>(appReducer, initialState: AppState()); // Initialize store
  runApp(StoreProvider<AppState>(
    store: store, // Provide store to the widget tree
    child: MyApp(),
  ));
}

// Main application widget
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Redux Compact Example',
      home: CounterPage(),
    );
  }
}

// Counter page widget
class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final store = StoreProvider.of<AppState>(context); // Access the store

    return Scaffold(
      appBar: AppBar(title: Text('Counter')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text('Counter Value: ${store.state.counter}'), // Display counter value
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: <Widget>[
                ElevatedButton(
                  onPressed: () {
                    store.dispatch(IncrementAction()); // Dispatch increment action
                  },
                  child: Text('Increment'),
                ),
                SizedBox(width: 20),
                ElevatedButton(
                  onPressed: () {
                    store.dispatch(DecrementAction()); // Dispatch decrement action
                  },
                  child: Text('Decrement'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

/*
Application Flow Explanation:
1. The app starts in the main function, where the store is initialized with the appReducer and an initial state.
2. The StoreProvider wraps the MyApp widget, making the store accessible throughout the widget tree.
3. The MyApp widget builds the main MaterialApp and sets the home to CounterPage.
4. In CounterPage, the current state of the counter is displayed using store.state.counter.
5. Two buttons are provided to increment and decrement the counter. When pressed, they dispatch the respective actions (IncrementAction or DecrementAction).
6. The app's state is updated based on the dispatched actions, and the UI reflects the changes automatically due to the reactive nature of the Redux pattern.
*/

```

## <-- END_MAIN -->

### Summary

In this blog post, we explored the `redux_compact` package, which provides a streamlined approach to state management in Flutter applications. We covered the setup process, basic usage, and provided a complete example demonstrating how to implement a simple counter application using Redux principles. The application flow was explained step-by-step, highlighting how actions trigger state changes and how the UI updates accordingly. This package is an excellent choice for developers looking for a compact and efficient way to manage state in their Flutter apps.