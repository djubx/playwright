<-- START_DESCRIPTION -->

MVVM (Model-View-ViewModel) is a popular architectural pattern used in software development to separate the application logic into three interconnected components. The MVVM pattern is widely used in Flutter app development to create maintainable, scalable, and testable codebases.
The `mvvm` package in Flutter provides a simple and efficient way to implement the MVVM pattern in your app. It allows you to separate your application logic into models, views, and view models, making it easier to manage and maintain your code.

Here are some key features of the `mvvm` package:

*   Separation of Concerns: The package allows you to separate your application logic into models, views, and view models, making it easier to manage and maintain your code.
*   Two-Way Data Binding: The package provides two-way data binding, which means that any changes to the view model are automatically reflected in the view, and vice versa.
*   Support for Multiple Platforms: The package supports multiple platforms, including Android and iOS.

When to use the `mvvm` package:

*   When you want to create a maintainable, scalable, and testable codebase.
*   When you want to separate your application logic into models, views, and view models.
*   When you want to use two-way data binding to simplify your code.

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

To use the `mvvm` package in your Flutter app, follow these steps:

1.  Add the `mvvm` package to your `pubspec.yaml` file:

    ```yml
dependencies:
  flutter:
    sdk: flutter
  mvvm: ^1.0.0
```

2.  Run `flutter pub get` to get the package.
3.  Import the package in your Dart file:

    ```dart
import 'package:mvvm/mvvm.dart';
```

4.  Create a model class that extends `Model`:

    ```dart
class RealFlutterModel extends Model {
  int _counter = 0;

  int get counter => _counter;

  void incrementCounter() {
    _counter++;
    notifyListeners();
  }
}
```

5.  Create a view model class that extends `ViewModel`:

    ```dart
class RealFlutterViewModel extends ViewModel<RealFlutterModel> {
  RealFlutterViewModel(RealFlutterModel model) : super(model);

  void incrementCounter() {
    model.incrementCounter();
  }
}
```

6.  Create a view that uses the view model:

    ```dart
class RealFlutterView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ViewModelProvider<RealFlutterViewModel>(
      create: (_) => RealFlutterViewModel(RealFlutterModel()),
      child: Scaffold(
        appBar: AppBar(
          title: Text('Real Flutter'),
        ),
        body: Center(
          child: Text('Counter: ${context.watch<RealFlutterViewModel>().model.counter}'),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            context.read<RealFlutterViewModel>().incrementCounter();
          },
          child: Icon(Icons.add),
        ),
      ),
    );
  }
}
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:mvvm/mvvm.dart';

// Model class
class RealFlutterModel extends Model {
  int _counter = 0;

  int get counter => _counter;

  void incrementCounter() {
    _counter++;
    notifyListeners();
  }
}

// View model class
class RealFlutterViewModel extends ViewModel<RealFlutterModel> {
  RealFlutterViewModel(RealFlutterModel model) : super(model);

  void incrementCounter() {
    model.incrementCounter();
  }
}

// View class
class RealFlutterView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Create a view model provider
    return ViewModelProvider<RealFlutterViewModel>(
      create: (_) => RealFlutterViewModel(RealFlutterModel()),
      child: Scaffold(
        appBar: AppBar(
          title: Text('Real Flutter'),
        ),
        body: Center(
          // Watch the view model to get the latest data
          child: Text('Counter: ${context.watch<RealFlutterViewModel>().model.counter}'),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            // Read the view model to call the increment counter method
            context.read<RealFlutterViewModel>().incrementCounter();
          },
          child: Icon(Icons.add),
        ),
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Real Flutter',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: RealFlutterView(),
    );
  }
}
```

// The application flow is as follows:
// 1. The `RealFlutterModel` class is created, which extends `Model`.
// 2. The `RealFlutterViewModel` class is created, which extends `ViewModel<RealFlutterModel>`.
// 3. The `RealFlutterView` class is created, which uses the `ViewModelProvider` to create a view model.
// 4. The view model is watched to get the latest data, and the `incrementCounter` method is called when the floating action button is pressed.
// 5. The `incrementCounter` method in the view model calls the `incrementCounter` method in the model.
// 6. The model notifies its listeners that the data has changed.
// 7. The view model provider rebuilds the view with the latest data.

<-- END_MAIN -->