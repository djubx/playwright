# Flutter Package: encryptions

## <-- START_DESCRIPTION -->

### Description

The `encryptions` package is a powerful Flutter library designed to provide encryption and decryption functionalities for sensitive data. It allows developers to secure user data, such as passwords, personal information, and any other sensitive content, ensuring that it remains confidential and protected from unauthorized access.

### When to Use

You should consider using the `encryptions` package in scenarios such as:
- Storing sensitive user information securely.
- Transmitting data over the network that needs to be encrypted.
- Implementing secure authentication mechanisms.

### Features

- **Symmetric Encryption**: Supports various symmetric encryption algorithms like AES, DES, and more.
- **Asymmetric Encryption**: Provides functionalities for RSA encryption and decryption.
- **Key Management**: Allows for secure key generation and management.
- **Base64 Encoding**: Facilitates easy encoding and decoding of encrypted data.
- **Cross-Platform Support**: Works seamlessly on both Android and iOS platforms.

## <-- END_DESCRIPTION -->

## <-- START_TUTORIAL -->

### Tutorial

#### Installation

To add the `encryptions` package to your Flutter project, include it in your `pubspec.yaml` file:

```yaml
dependencies:
  encryptions: ^latest_version
```

Make sure to run `flutter pub get` to install the package.

#### Platform-Specific Configuration

**For Android:**
- Ensure that your `minSdkVersion` is set to at least 21 in your `android/app/build.gradle` file:

```groovy
android {
    ...
    defaultConfig {
        ...
        minSdkVersion 21
    }
}
```

**For iOS:**
- No specific configurations are required for iOS, but ensure that your project is set up to support the latest Swift version.

#### Basic Usage

To use the `encryptions` package, you need to import it into your Dart file:

```dart
import 'package:encryptions/encryptions.dart';
```

You can then create an instance of the `RealFlutter` class to handle encryption and decryption tasks.

## <-- END_TUTORIAL -->

## <-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:encryptions/encryptions.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Encryption Example',
      home: EncryptionHome(),
    );
  }
}

class EncryptionHome extends StatefulWidget {
  @override
  _EncryptionHomeState createState() => _EncryptionHomeState();
}

class _EncryptionHomeState extends State<EncryptionHome> {
  final String plainText = "Hello, Flutter!";
  String encryptedText = "";
  String decryptedText = "";
  final key = Key.fromUtf8('16characterkey!'); // AES key must be 16, 24, or 32 bytes
  final iv = IV.fromLength(16); // Initialization vector

  @override
  void initState() {
    super.initState();
    encryptData(); // Call the encryption method on initialization
  }

  void encryptData() {
    // Create an AES encrypter instance
    final encrypter = Encrypter(AES(key));
    
    // Encrypt the plain text
    encryptedText = encrypter.encrypt(plainText, iv: iv).base64;
    
    // Decrypt the encrypted text
    decryptedText = encrypter.decrypt64(encryptedText, iv: iv);
    
    // Update the UI with the encrypted and decrypted text
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Encryption Example'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Plain Text: $plainText'),
            SizedBox(height: 20),
            Text('Encrypted Text: $encryptedText'),
            SizedBox(height: 20),
            Text('Decrypted Text: $decryptedText'),
          ],
        ),
      ),
    );
  }
}
```

### Application Flow Explanation

// The main function initializes the Flutter app by calling runApp with the RealFlutter widget.
// The RealFlutter widget sets up the MaterialApp with a title and a home page, which is the EncryptionHome widget.
// The EncryptionHome widget is a stateful widget that manages the encryption and decryption process.
// In the initState method, the encryptData method is called to perform encryption when the widget is initialized.
// The encryptData method creates an AES encrypter instance using a predefined key and IV.
// It encrypts the plain text and stores the result in the encryptedText variable.
// It then decrypts the encrypted text back to plain text and stores it in the decryptedText variable.
// Finally, the setState method is called to update the UI with the encrypted and decrypted text.
// The build method constructs the UI, displaying the plain text, encrypted text, and decrypted text in a column layout.

## <-- END_MAIN -->

### Summary

In this blog post, we explored the `encryptions` Flutter package, which provides robust encryption and decryption capabilities for securing sensitive data. We walked through the installation process, platform-specific configurations, and provided a complete example demonstrating how to encrypt and decrypt data using AES. The application flow was explained step-by-step, showcasing how the package can be effectively utilized in a Flutter project. This package is ideal for developers looking to enhance the security of their applications by protecting user data.