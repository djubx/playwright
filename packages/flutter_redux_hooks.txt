<-- START_DESCRIPTION -->

# Flutter Redux Hooks Package
================================

The `flutter_redux_hooks` package provides a set of hooks for using Redux with Flutter. It allows you to connect your Flutter widgets to a Redux store and dispatch actions to update the store.

## When to Use
--------------

Use this package when you want to manage global state in your Flutter app using Redux. It's particularly useful when you have a complex app with many interconnected components.

## Features
------------

*   Connects Flutter widgets to a Redux store
*   Dispatches actions to update the store
*   Supports async actions
*   Works with both Android and iOS

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up Flutter Redux Hooks
================================

## Step 1: Add the Package
-------------------------

Add the `flutter_redux_hooks` package to your `pubspec.yaml` file:

```yml
dependencies:
  flutter_redux_hooks: ^1.0.0
```

Then run `flutter pub get` to install the package.

## Step 2: Create a Redux Store
------------------------------

Create a Redux store by defining a reducer function and creating a store instance:

```dart
import 'package:redux/redux.dart';

// Define a reducer function
int counterReducer(int state, dynamic action) {
  if (action == 'INCREMENT') {
    return state + 1;
  } else if (action == 'DECREMENT') {
    return state - 1;
  } else {
    return state;
  }
}

// Create a store instance
Store<int> store = Store<int>(counterReducer, initialState: 0);
```

## Step 3: Connect Your Widgets
------------------------------

Use the `useSelector` and `useDispatch` hooks to connect your widgets to the Redux store:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux_hooks/flutter_redux_hooks.dart';

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Use the useSelector hook to select the current state
    int count = useSelector((state) => state);

    // Use the useDispatch hook to dispatch actions
    Function dispatch = useDispatch();

    return Scaffold(
      appBar: AppBar(
        title: Text('Flutter Redux Hooks'),
      ),
      body: Center(
        child: Text('Count: $count'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Dispatch an action to increment the count
          dispatch('INCREMENT');
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux_hooks/flutter_redux_hooks.dart';
import 'package:redux/redux.dart';

// Define a reducer function
int counterReducer(int state, dynamic action) {
  if (action == 'INCREMENT') {
    return state + 1;
  } else if (action == 'DECREMENT') {
    return state - 1;
  } else {
    return state;
  }
}

// Create a store instance
Store<int> store = Store<int>(counterReducer, initialState: 0);

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Redux Hooks',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: RealFlutter(),
    );
  }
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Use the useSelector hook to select the current state
    int count = useSelector((state) => state);

    // Use the useDispatch hook to dispatch actions
    Function dispatch = useDispatch();

    return Scaffold(
      appBar: AppBar(
        title: Text('Flutter Redux Hooks'),
      ),
      body: Center(
        child: Text('Count: $count'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Dispatch an action to increment the count
          dispatch('INCREMENT');
        },
        child: Icon(Icons.add),
      ),
    );
  }
}

// The app starts by creating a store instance with the counterReducer function.
// The store is then passed to the MaterialApp widget, which makes it available to all widgets in the app.
// The RealFlutter widget uses the useSelector hook to select the current state from the store.
// The useSelector hook takes a selector function as an argument, which is used to select the desired state from the store.
// In this case, the selector function simply returns the current state.
// The RealFlutter widget also uses the useDispatch hook to dispatch actions to the store.
// The useDispatch hook returns a dispatch function that can be used to dispatch actions.
// When the floating action button is pressed, the dispatch function is called with the 'INCREMENT' action.
// The counterReducer function is then called with the current state and the 'INCREMENT' action, and it returns a new state with the count incremented by 1.
// The new state is then stored in the store, and the useSelector hook is notified of the change.
// The useSelector hook then updates the RealFlutter widget with the new state, which causes the widget to rebuild with the new count.
```

<-- END_MAIN -->