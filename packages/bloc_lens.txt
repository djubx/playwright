```markdown
<!-- START_DESCRIPTION -->
# Understanding the bloc_lens Flutter Package

The `bloc_lens` package is a powerful tool designed to enhance the development experience when working with the BLoC (Business Logic Component) pattern in Flutter applications. It provides a visual representation of the BLoC state and events, making it easier for developers to debug and understand the flow of data within their applications.

## When to Use `bloc_lens`

You should consider using `bloc_lens` in scenarios where:
- You are building complex applications that utilize multiple BLoCs.
- You need to debug and visualize the state changes and events in your application.
- You want to improve the maintainability of your code by having a clear understanding of the BLoC interactions.

## Key Features
- **Visual State Management**: Provides a graphical interface to visualize the state and events of your BLoCs.
- **Real-time Updates**: Automatically updates the visual representation as the state changes.
- **Easy Integration**: Simple to integrate into existing Flutter applications using the BLoC pattern.
- **Debugging Aid**: Helps in identifying issues in the BLoC flow by providing a clear view of state transitions.

Overall, `bloc_lens` is an invaluable tool for Flutter developers looking to streamline their BLoC implementations and enhance their debugging capabilities.
<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
# Setting Up and Using the bloc_lens Package

## Installation

To get started with `bloc_lens`, you need to add it to your `pubspec.yaml` file. Open your `pubspec.yaml` and add the following dependency:

```yaml
dependencies:
  flutter:
    sdk: flutter
  bloc_lens: ^latest_version
```

Make sure to replace `^latest_version` with the latest version available on [pub.dev](https://pub.dev/packages/bloc_lens).

## Platform-Specific Configuration

### Android
For Android, ensure that your `minSdkVersion` is set to at least 21 in your `android/app/build.gradle` file:

```gradle
android {
    ...
    defaultConfig {
        ...
        minSdkVersion 21
    }
}
```

### iOS
For iOS, you may need to enable the use of Swift in your project if you haven't already. Open your `ios/Runner.xcworkspace` in Xcode and ensure that the project settings are configured to support Swift.

## Using bloc_lens

To use `bloc_lens`, you need to wrap your application with the `BlocLens` widget. Hereâ€™s how you can do it:

```dart
import 'package:flutter/material.dart';
import 'package:bloc_lens/bloc_lens.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocLens(
      child: MaterialApp(
        title: 'Bloc Lens Example',
        home: RealFlutter(),
      ),
    );
  }
}
```

In this example, we wrap our `MaterialApp` with `BlocLens`, which will allow us to visualize the BLoC states and events.

Now, you can create your BLoCs and use them as you normally would. The `bloc_lens` package will automatically track the state changes and provide a visual representation.

<!-- END_TUTORIAL -->

<!-- START_MAIN -->
# Complete Example of Using bloc_lens

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:bloc_lens/bloc_lens.dart';

// Define a simple BLoC for demonstration
class CounterCubit extends Cubit<int> {
  CounterCubit() : super(0); // Initial state is 0

  void increment() => emit(state + 1); // Increment the counter
  void decrement() => emit(state - 1); // Decrement the counter
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => CounterCubit(), // Provide the CounterCubit
      child: Scaffold(
        appBar: AppBar(
          title: Text('Bloc Lens Example'),
        ),
        body: Center(
          child: BlocBuilder<CounterCubit, int>(
            builder: (context, count) {
              return Text(
                'Counter Value: $count', // Display the current counter value
                style: TextStyle(fontSize: 24),
              );
            },
          ),
        ),
        floatingActionButton: Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            FloatingActionButton(
              onPressed: () => context.read<CounterCubit>().decrement(), // Decrement button
              tooltip: 'Decrement',
              child: Icon(Icons.remove),
            ),
            SizedBox(width: 10),
            FloatingActionButton(
              onPressed: () => context.read<CounterCubit>().increment(), // Increment button
              tooltip: 'Increment',
              child: Icon(Icons.add),
            ),
          ],
        ),
      ),
    );
  }
}
```

```dart
// Explanation of the application flow:

// 1. The application starts with the main function, which runs the MyApp widget.
// 2. MyApp is wrapped in a BlocLens widget, allowing us to visualize BLoC states and events.
// 3. Inside MyApp, we create a MaterialApp with a title and set the home to RealFlutter.
// 4. In RealFlutter, we use BlocProvider to provide an instance of CounterCubit to the widget tree.
// 5. The BlocBuilder listens to the CounterCubit and rebuilds the UI whenever the state changes.
// 6. The current counter value is displayed in the center of the screen.
// 7. Two FloatingActionButtons are provided to increment and decrement the counter.
// 8. When the buttons are pressed, they call the respective methods in the CounterCubit, which updates the state.
// 9. The BlocBuilder automatically rebuilds the UI with the new counter value, and the BlocLens visualizes the state changes.
```
<!-- END_MAIN -->
```

This structured blog post provides a comprehensive overview of the `bloc_lens` package, including its features, setup instructions, and a complete example with detailed comments explaining the application flow. This format is designed to be informative and accessible for both beginner and experienced Flutter developers.