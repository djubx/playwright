```markdown
<-- START_DESCRIPTION -->

# Understanding the `connectivity_wrapper` Flutter Package

The `connectivity_wrapper` package is a powerful tool for Flutter developers who need to manage network connectivity in their applications. This package provides a simple and effective way to handle network changes and ensure that your app responds appropriately to connectivity issues.

## When to Use `connectivity_wrapper`

- **Offline-First Applications**: If your app needs to function offline and sync data when a connection is available.
- **Real-Time Updates**: For apps that require real-time data updates, such as chat applications or live sports scores.
- **User Notifications**: To inform users about connectivity changes, ensuring they are aware of when the app is offline or online.

## Key Features

- **Connectivity Status Monitoring**: Continuously monitors the network status and notifies the app of any changes.
- **Offline Mode Handling**: Allows developers to define custom behavior when the app is offline.
- **UI Widgets**: Provides widgets to easily display connectivity status to users.

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up and Using `connectivity_wrapper`

In this tutorial, we will walk through the setup and usage of the `connectivity_wrapper` package in a Flutter application. We will cover platform-specific configurations for both Android and iOS.

## Setup Process

1. **Add Dependency**: First, add the `connectivity_wrapper` package to your `pubspec.yaml` file.

   ```yaml
   dependencies:
     flutter:
       sdk: flutter
     connectivity_wrapper: ^2.0.0
   ```

2. **Platform-Specific Configuration**:

   - **Android**: Ensure that your `AndroidManifest.xml` includes the necessary permissions for internet access.

     ```xml
     <uses-permission android:name="android.permission.INTERNET"/>
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
     ```

   - **iOS**: Update your `Info.plist` to include the required permissions.

     ```xml
     <key>NSAppTransportSecurity</key>
     <dict>
       <key>NSAllowsArbitraryLoads</key>
       <true/>
     </dict>
     ```

3. **Initialize the Package**: In your `main.dart` file, wrap your app with `ConnectivityAppWrapper` and use `ConnectivityWidgetWrapper` to manage connectivity-dependent widgets.

## Using the Package

- **ConnectivityAppWrapper**: This widget should wrap your entire application to provide connectivity status throughout the app.
- **ConnectivityWidgetWrapper**: Use this widget to wrap parts of your UI that need to respond to connectivity changes.

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:connectivity_wrapper/connectivity_wrapper.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Wrap the entire app with ConnectivityAppWrapper
    return ConnectivityAppWrapper(
      app: MaterialApp(
        title: 'Connectivity Wrapper Demo',
        home: ConnectivityWidgetWrapper(
          disableInteraction: true,
          offlineWidget: OfflineScreen(),
          child: HomeScreen(),
        ),
      ),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Main screen of the app
    return Scaffold(
      appBar: AppBar(
        title: Text('Home Screen'),
      ),
      body: Center(
        child: Text('You are online!'),
      ),
    );
  }
}

class OfflineScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Screen displayed when offline
    return Scaffold(
      appBar: AppBar(
        title: Text('Offline'),
      ),
      body: Center(
        child: Text('You are offline. Please check your connection.'),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app is wrapped with ConnectivityAppWrapper to monitor connectivity status globally.
// 2. ConnectivityWidgetWrapper is used to manage the UI based on connectivity status.
// 3. When online, HomeScreen is displayed, showing a message that the user is online.
// 4. If the device goes offline, OfflineScreen is shown, informing the user of the connectivity issue.
// 5. The app automatically switches between these screens based on the network status.
```

<-- END_MAIN -->
```