# Hydrated Riverpod: A Comprehensive Guide

## <-- START_DESCRIPTION -->

### Overview of `hydrated_riverpod`

The `hydrated_riverpod` package is an extension of the popular Riverpod state management library for Flutter. It provides a way to persist state across app restarts, making it ideal for applications that require data retention, such as user preferences, session data, or any other state that should survive app closures.

### When to Use `hydrated_riverpod`

You should consider using `hydrated_riverpod` when:
- You need to maintain the state of your application even after it is closed and reopened.
- You want to leverage the powerful features of Riverpod while adding persistence capabilities.
- You are building applications that require user settings, themes, or any data that should be retained across sessions.

### Key Features

- **State Persistence**: Automatically saves and restores state using the `hydrated_storage` package.
- **Integration with Riverpod**: Seamlessly integrates with Riverpod's providers, allowing you to manage state effectively.
- **Easy to Use**: Simple API that allows developers to focus on building features rather than managing state persistence.
- **Cross-Platform Support**: Works on both Android and iOS, ensuring a consistent experience across devices.

## <-- END_DESCRIPTION -->

## <-- START_TUTORIAL -->

### Setup Process

To get started with `hydrated_riverpod`, follow these steps:

1. **Add Dependencies**: Open your `pubspec.yaml` file and add the following dependencies:

   ```yaml
   dependencies:
     flutter:
       sdk: flutter
     flutter_riverpod: ^2.0.0
     hydrated_riverpod: ^1.0.0
     hydrated_storage: ^1.0.0
   ```

2. **Platform-Specific Configuration**:
   - **Android**: Ensure you have the necessary permissions in your `AndroidManifest.xml` if you are using any specific storage features.
   - **iOS**: No additional configuration is typically required, but ensure your app has the correct entitlements if you are using secure storage.

3. **Initialization**: In your main application file, you need to initialize the `HydratedStorage` before running your app. This is crucial for the persistence feature to work.

   ```dart
   void main() async {
     WidgetsFlutterBinding.ensureInitialized();
     await HydratedStorage.build();
     runApp(const ProviderScope(child: MyApp()));
   }
   ```

### Using the Package

1. **Creating a Provider**: You can create a `StateNotifierProvider` that uses `HydratedNotifier` to manage your state.

   ```dart
   class CounterNotifier extends HydratedNotifier<int> {
     CounterNotifier() : super(0); // Initial state

     void increment() => state++;
     void decrement() => state--;
   }

   final counterProvider = StateNotifierProvider<CounterNotifier, int>((ref) {
     return CounterNotifier();
   });
   ```

2. **Using the Provider in Your Widget**:

   ```dart
   class CounterWidget extends ConsumerWidget {
     @override
     Widget build(BuildContext context, WidgetRef ref) {
       final count = ref.watch(counterProvider);
       return Column(
         children: [
           Text('Count: $count'),
           ElevatedButton(
             onPressed: () => ref.read(counterProvider.notifier).increment(),
             child: const Text('Increment'),
           ),
           ElevatedButton(
             onPressed: () => ref.read(counterProvider.notifier).decrement(),
             child: const Text('Decrement'),
           ),
         ],
       );
     }
   }
   ```

## <-- END_TUTORIAL -->

## <-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hydrated_riverpod/hydrated_riverpod.dart';
import 'package:hydrated_storage/hydrated_storage.dart';

void main() async {
  // Ensure Flutter binding is initialized
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize HydratedStorage for state persistence
  await HydratedStorage.build();
  
  // Run the app with ProviderScope for Riverpod
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Hydrated Riverpod Example',
      home: const CounterScreen(),
    );
  }
}

// Create a CounterNotifier that extends HydratedNotifier
class CounterNotifier extends HydratedNotifier<int> {
  CounterNotifier() : super(0); // Initial state is 0

  // Increment the state
  void increment() => state++;
  
  // Decrement the state
  void decrement() => state--;
}

// Define a provider for the CounterNotifier
final counterProvider = StateNotifierProvider<CounterNotifier, int>((ref) {
  return CounterNotifier();
});

// Create a CounterScreen widget to display and interact with the counter
class CounterScreen extends ConsumerWidget {
  const CounterScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch the counterProvider to get the current count
    final count = ref.watch(counterProvider);
    
    return Scaffold(
      appBar: AppBar(title: const Text('Hydrated Riverpod Counter')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Display the current count
            Text('Count: $count', style: Theme.of(context).textTheme.headline4),
            // Button to increment the count
            ElevatedButton(
              onPressed: () => ref.read(counterProvider.notifier).increment(),
              child: const Text('Increment'),
            ),
            // Button to decrement the count
            ElevatedButton(
              onPressed: () => ref.read(counterProvider.notifier).decrement(),
              child: const Text('Decrement'),
            ),
          ],
        ),
      ),
    );
  }
}

/*
Application Flow Explanation:
1. The app starts with the main function, initializing the HydratedStorage for state persistence.
2. The MyApp widget is created, which sets up the MaterialApp and the home screen.
3. The CounterScreen widget is built, which uses the counterProvider to get the current count.
4. The user can increment or decrement the count using the provided buttons.
5. The state is automatically persisted, so if the app is closed and reopened, the last count will be restored.
*/

```

## <-- END_MAIN -->

### Summary

In this blog post, we explored the `hydrated_riverpod` package, which allows Flutter developers to manage state with persistence using Riverpod. We covered the setup process, including platform-specific configurations, and provided a complete example of a counter application that demonstrates the key features of the package. The application flow was explained step-by-step through comments in the code, highlighting how state is managed and persisted across app sessions. This package is particularly useful for applications that require data retention, making it a valuable addition to any Flutter developer's toolkit.