<-- START_DESCRIPTION -->

# Flutter Debouncer Package
================================

The `flutter_debouncer` package is a utility library for Flutter that provides a simple way to debounce user input, API calls, or any other type of event that may be triggered rapidly. Debouncing is a technique used to prevent multiple events from being triggered within a short period of time, which can help improve performance and prevent unnecessary computations.

## When to Use
--------------

You can use the `flutter_debouncer` package in a variety of scenarios, such as:

* Debouncing user input in a search bar to prevent multiple API calls
* Debouncing button clicks to prevent multiple submissions
* Debouncing scroll events to prevent excessive computations

## Features
------------

The `flutter_debouncer` package provides the following features:

* Simple and easy-to-use API
* Customizable debounce duration
* Support for both synchronous and asynchronous events

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up the Package
-------------------------

To use the `flutter_debouncer` package, you need to add it to your `pubspec.yaml` file:

```yml
dependencies:
  flutter_debouncer: ^1.0.0
```

Then, run `flutter pub get` to install the package.

## Using the Package
---------------------

To use the package, you need to create an instance of the `Debouncer` class:

```dart
import 'package:flutter_debouncer/flutter_debouncer.dart';

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  final Debouncer _debouncer = Debouncer(delay: Duration(milliseconds: 500));

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Flutter Debouncer Example'),
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            _debouncer.run(() {
              // Code to be executed after debounce
            });
          },
          child: Text('Click me'),
        ),
      ),
    );
  }
}
```

In the above example, we create a `Debouncer` instance with a delay of 500 milliseconds. When the button is clicked, the `_debouncer.run` method is called, which will execute the code inside the callback after the debounce delay.

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:flutter_debouncer/flutter_debouncer.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Debouncer Example',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: RealFlutter(),
    );
  }
}

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  final Debouncer _debouncer = Debouncer(delay: Duration(milliseconds: 500));
  int _counter = 0;

  void _incrementCounter() {
    _debouncer.run(() {
      setState(() {
        _counter++;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Flutter Debouncer Example'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text(
              'You have clicked the button this many times:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ),
    );
  }
}

// The application flow is as follows:
// 1. The user clicks the floating action button.
// 2. The _incrementCounter method is called.
// 3. The _debouncer.run method is called, which will execute the code inside the callback after the debounce delay.
// 4. After the debounce delay, the setState method is called, which will update the _counter variable.
// 5. The updated _counter value is displayed on the screen.
// The debounce delay prevents the _counter value from being updated rapidly, even if the user clicks the button multiple times in quick succession.

// The above code demonstrates the usage of the flutter_debouncer package to debounce user input.
// The debounce delay can be customized to suit the needs of the application.
// The package can be used in a variety of scenarios, such as debouncing button clicks, scroll events, or API calls.
```

<-- END_MAIN -->