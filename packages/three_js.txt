# Flutter Package: three_js

## <-- START_DESCRIPTION -->

### Description

The `three_js` Flutter package is a powerful tool that allows developers to integrate 3D graphics into their Flutter applications using the popular Three.js library. This package is particularly useful for creating immersive experiences, such as games, simulations, and interactive visualizations. With `three_js`, developers can leverage the capabilities of WebGL to render complex 3D scenes directly within their Flutter apps.

### When to Use

You might consider using the `three_js` package in scenarios such as:
- Developing 3D games or interactive applications.
- Creating educational tools that require 3D visualizations.
- Building augmented reality (AR) or virtual reality (VR) experiences.
- Implementing data visualizations that benefit from a 3D perspective.

### Features

- **3D Rendering**: Utilize the power of WebGL for high-performance 3D rendering.
- **Scene Graph**: Create and manage complex scenes with multiple objects, lights, and cameras.
- **Animation Support**: Animate objects and scenes using built-in animation capabilities.
- **Interactivity**: Handle user interactions such as clicks and gestures to manipulate 3D objects.
- **Cross-Platform**: Works seamlessly on both Android and iOS devices.

## <-- END_DESCRIPTION -->

## <-- START_TUTORIAL -->

### Tutorial

To get started with the `three_js` package, follow these steps:

#### Step 1: Add Dependency

Add the `three_js` package to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  three_js: ^latest_version
```

Make sure to replace `^latest_version` with the latest version available on [pub.dev](https://pub.dev/packages/three_js).

#### Step 2: Platform-Specific Configuration

**For Android:**
- Ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 21:

```groovy
android {
    ...
    defaultConfig {
        ...
        minSdkVersion 21
    }
}
```

**For iOS:**
- Open `ios/Runner/Info.plist` and add the following to allow WebGL content:

```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```

#### Step 3: Import the Package

In your Dart file, import the `three_js` package:

```dart
import 'package:three_js/three_js.dart';
```

#### Step 4: Initialize the 3D Scene

You can now create a basic 3D scene using the `three_js` package. Below is a simple example that demonstrates how to set up a scene with a rotating cube.

## <-- END_TUTORIAL -->

## <-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:three_js/three_js.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  late Scene scene; // Declare a Scene object
  late Camera camera; // Declare a Camera object
  late WebGLRenderer renderer; // Declare a WebGLRenderer object
  late CubeGeometry cubeGeometry; // Declare a CubeGeometry object
  late MeshBasicMaterial cubeMaterial; // Declare a MeshBasicMaterial object
  late Mesh cube; // Declare a Mesh object

  @override
  void initState() {
    super.initState();
    // Initialize the 3D scene
    init3DScene();
  }

  void init3DScene() {
    // Create a new scene
    scene = Scene();

    // Set up the camera with a field of view, aspect ratio, and near/far planes
    camera = PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5; // Move the camera back

    // Create a renderer and set its size
    renderer = WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.append(renderer.domElement); // Append the renderer to the DOM

    // Create a cube geometry and a basic material
    cubeGeometry = CubeGeometry(1, 1, 1);
    cubeMaterial = MeshBasicMaterial(color: Color(0x00ff00)); // Green color

    // Create a mesh with the geometry and material
    cube = Mesh(cubeGeometry, cubeMaterial);
    scene.add(cube); // Add the cube to the scene

    // Start the animation loop
    animate();
  }

  void animate() {
    // Request the next animation frame
    requestAnimationFrame((_) {
      // Rotate the cube for animation
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;

      // Render the scene from the perspective of the camera
      renderer.render(scene, camera);
      animate(); // Call animate again for the next frame
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('3D Cube with three_js')),
        body: Center(child: Text('3D Cube is rendering...')),
      ),
    );
  }
}
```

### Application Flow Explanation

// The main function initializes the Flutter app by calling runApp with the RealFlutter widget.
// The RealFlutter widget is a StatefulWidget that manages the 3D scene.
// In the initState method, we call init3DScene to set up our 3D environment.
// The init3DScene method creates a new Scene, sets up a PerspectiveCamera, and initializes a WebGLRenderer.
// The renderer's size is set to the window's dimensions, and it is appended to the DOM.
// A cube geometry and a basic material are created, and a Mesh is formed by combining them.
// The cube is added to the scene, and the animate method is called to start the rendering loop.
// The animate method continuously updates the cube's rotation and renders the scene from the camera's perspective.
// The build method returns a simple MaterialApp with an AppBar and a message indicating that the 3D cube is rendering.

## <-- END_MAIN -->

### Summary

The `three_js` package provides a robust framework for integrating 3D graphics into Flutter applications. By following the tutorial and example provided, developers can quickly set up a basic 3D scene and begin exploring the capabilities of Three.js within their Flutter projects. Whether for games, simulations, or visualizations, `three_js` opens up a world of possibilities for creating engaging user experiences.