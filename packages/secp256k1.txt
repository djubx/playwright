<-- START_DESCRIPTION -->

# secp256k1 Flutter Package
The secp256k1 Flutter package is a cryptographic library that provides an implementation of the secp256k1 elliptic curve, which is used in various cryptocurrencies such as Bitcoin and Ethereum. This package allows developers to generate public and private key pairs, sign messages, and verify signatures.

## When to Use
This package is useful when developing cryptocurrency-related applications, such as wallets, exchanges, or payment systems. It can also be used in other scenarios where secure key management and message signing are required.

## Features

* Generate public and private key pairs
* Sign messages using the private key
* Verify signatures using the public key
* Support for various hash functions (e.g., SHA-256, SHA-512)

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setup and Usage
To use the secp256k1 Flutter package, follow these steps:

### 1. Add the package to your pubspec.yaml file
```yml
dependencies:
  secp256k1: ^1.0.0
```

### 2. Import the package in your Dart file
```dart
import 'package:secp256k1/secp256k1.dart';
```

### 3. Generate a public and private key pair
```dart
void main() {
  final keyPair = Secp256k1.generateKeyPair();
  print('Private key: ${keyPair.privateKey}');
  print('Public key: ${keyPair.publicKey}');
}
```

### 4. Sign a message using the private key
```dart
void main() {
  final keyPair = Secp256k1.generateKeyPair();
  final message = 'Hello, World!';
  final signature = Secp256k1.sign(message, keyPair.privateKey);
  print('Signature: $signature');
}
```

### 5. Verify a signature using the public key
```dart
void main() {
  final keyPair = Secp256k1.generateKeyPair();
  final message = 'Hello, World!';
  final signature = Secp256k1.sign(message, keyPair.privateKey);
  final isValid = Secp256k1.verify(message, signature, keyPair.publicKey);
  print('Is valid: $isValid');
}
```

### Platform-Specific Details
No platform-specific configurations are required for this package.

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:secp256k1/secp256k1.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  final _keyPair = Secp256k1.generateKeyPair();
  final _messageController = TextEditingController();
  String _signature = '';
  bool _isValid = false;

  void _signMessage() {
    final message = _messageController.text;
    final signature = Secp256k1.sign(message, _keyPair.privateKey);
    setState(() {
      _signature = signature;
    });
  }

  void _verifySignature() {
    final message = _messageController.text;
    final isValid = Secp256k1.verify(message, _signature, _keyPair.publicKey);
    setState(() {
      _isValid = isValid;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('Secp256k1 Example'),
        ),
        body: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            children: [
              TextField(
                controller: _messageController,
                decoration: InputDecoration(
                  labelText: 'Message',
                  border: OutlineInputBorder(),
                ),
              ),
              SizedBox(height: 20),
              ElevatedButton(
                onPressed: _signMessage,
                child: Text('Sign Message'),
              ),
              SizedBox(height: 20),
              Text('Signature: $_signature'),
              SizedBox(height: 20),
              ElevatedButton(
                onPressed: _verifySignature,
                child: Text('Verify Signature'),
              ),
              SizedBox(height: 20),
              Text('Is valid: $_isValid'),
            ],
          ),
        ),
      ),
    );
  }
}

// The application flow is as follows:
// 1. The user enters a message in the text field.
// 2. The user clicks the "Sign Message" button, which generates a signature using the private key.
// 3. The signature is displayed on the screen.
// 4. The user clicks the "Verify Signature" button, which verifies the signature using the public key.
// 5. The result of the verification is displayed on the screen.

// In summary, this example demonstrates how to generate a public and private key pair, sign a message using the private key, and verify a signature using the public key.
```

<-- END_MAIN -->