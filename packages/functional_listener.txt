<-- START_DESCRIPTION -->

# Functional Listener Package in Flutter
=====================================

The `functional_listener` package in Flutter is a utility package that allows you to handle callbacks and listeners in a more functional programming style. It provides a simple and efficient way to manage callbacks and listeners, making your code more readable and maintainable.

### When to Use

You can use the `functional_listener` package in situations where you need to handle multiple callbacks or listeners, such as:

* Handling multiple button clicks
* Managing API responses
* Handling WebSocket events

### Features

The `functional_listener` package provides the following features:

* Simple and efficient way to manage callbacks and listeners
* Supports multiple listeners for a single event
* Easy to use and integrate with existing Flutter code

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up and Using the Package
=====================================

To use the `functional_listener` package, follow these steps:

### Step 1: Add the Package to Your Pubspec File

Add the following line to your `pubspec.yaml` file:
```yml
dependencies:
  functional_listener: ^1.0.0
```
### Step 2: Import the Package

Import the package in your Dart file:
```dart
import 'package:functional_listener/functional_listener.dart';
```
### Step 3: Create a Listener

Create a listener using the `Listener` class:
```dart
final listener = Listener(
  onEvent: (event) {
    // Handle the event
  },
);
```
### Step 4: Add the Listener to a Widget

Add the listener to a widget using the `ListenerWidget` class:
```dart
ListenerWidget(
  listener: listener,
  child: // Your widget here
)
```
### Platform-Specific Details

* For Android, you need to add the following line to your `AndroidManifest.xml` file:
```xml
<application
  ...
  android:hardwareAccelerated="true"
  ...
>
```
* For iOS, you need to add the following line to your `Info.plist` file:
```xml
<key>UIViewControllerBasedStatusBarAppearance</key>
<false/>
```
### Required Configurations and Optimizations

* Make sure to dispose of the listener when it's no longer needed to avoid memory leaks.
* Use the `ListenerWidget` class to handle the listener's lifecycle.

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:functional_listener/functional_listener.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Functional Listener Demo',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  final listener = Listener(
    onEvent: (event) {
      // Handle the event
      print('Event received: $event');
    },
  );

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Functional Listener Demo'),
      ),
      body: Center(
        child: ListenerWidget(
          listener: listener,
          child: ElevatedButton(
            onPressed: () {
              // Send an event to the listener
              listener.sendEvent('Button clicked!');
            },
            child: Text('Click me!'),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    // Dispose of the listener to avoid memory leaks
    listener.dispose();
    super.dispose();
  }
}

// The application flow is as follows:
// 1. The user clicks the button, which sends an event to the listener.
// 2. The listener receives the event and handles it by printing a message to the console.
// 3. The listener is disposed of when the widget is removed from the tree to avoid memory leaks.
```

The code flows as follows:

1. The user clicks the button, which sends an event to the listener.
2. The listener receives the event and handles it by printing a message to the console.
3. The listener is disposed of when the widget is removed from the tree to avoid memory leaks.

<-- END_MAIN -->