<-- START_DESCRIPTION -->

**Inject Annotation Flutter Package: A High-Level Overview**
===========================================================

The `inject_annotation` Flutter package is a powerful tool for simplifying dependency injection in Flutter applications. It allows developers to easily manage dependencies between objects and provides a simple way to inject instances of classes into other classes.

**When to Use This Package**
---------------------------

This package is particularly useful when building complex applications with multiple layers of dependencies. It helps to decouple objects from each other, making it easier to test, maintain, and extend the application.

**Key Features**
----------------

*   Simplifies dependency injection in Flutter applications
*   Allows for easy management of dependencies between objects
*   Provides a simple way to inject instances of classes into other classes
*   Supports both singleton and non-singleton instances

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

**Setting Up and Using the Inject Annotation Package**
=====================================================

### Step 1: Add the Package to Your Project

To use the `inject_annotation` package, you need to add it to your project's `pubspec.yaml` file:

```yml
dependencies:
  inject_annotation: ^1.0.0
```

Then, run `flutter pub get` to install the package.

### Step 2: Create a Class with Injectable Dependencies

Create a class that has dependencies you want to inject:

```dart
// real_flutter.dart
import 'package:inject_annotation/inject_annotation.dart';

part 'real_flutter.g.dart';

@injectable
class RealFlutter {
  final Logger _logger;

  RealFlutter(this._logger);

  void doSomething() {
    _logger.log('Doing something');
  }
}
```

In this example, the `RealFlutter` class has a dependency on the `Logger` class.

### Step 3: Generate the Injectable Code

Run the following command to generate the injectable code:

```bash
flutter pub run build_runner build
```

This will generate a `real_flutter.g.dart` file that contains the injectable code.

### Step 4: Use the Injectable Class

Now you can use the `RealFlutter` class with the injected dependency:

```dart
// main.dart
import 'package:real_flutter/real_flutter.dart';

void main() {
  final realFlutter = RealFlutter(Logger());
  realFlutter.doSomething();
}
```

In this example, the `Logger` instance is injected into the `RealFlutter` class.

### Platform-Specific Details

The `inject_annotation` package works on both Android and iOS platforms. However, you need to configure the package differently for each platform.

#### Android

On Android, you need to add the following configuration to your `android/app/build.gradle` file:

```groovy
android {
  // ...
  defaultConfig {
    // ...
    javaCompileOptions {
      annotationProcessorOptions {
        arguments = ['inject_annotation']
      }
    }
  }
}
```

#### iOS

On iOS, you need to add the following configuration to your `ios/Podfile` file:

```ruby
target 'Runner' do
  # ...
  pod 'InjectAnnotation', :path => '../.symlinks/plugins/inject_annotation/ios'
end
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:inject_annotation/inject_annotation.dart';
import 'package:real_flutter/real_flutter.dart';

void main() {
  // Create an instance of the Logger class
  final logger = Logger();

  // Create an instance of the RealFlutter class with the injected Logger instance
  final realFlutter = RealFlutter(logger);

  // Use the RealFlutter instance
  realFlutter.doSomething();

  // Run the Flutter app
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Inject Annotation Demo',
      home: Scaffold(
        appBar: AppBar(
          title: Text('Inject Annotation Demo'),
        ),
        body: Center(
          child: Text('Hello, World!'),
        ),
      ),
    );
  }
}

// real_flutter.dart
import 'package:inject_annotation/inject_annotation.dart';

part 'real_flutter.g.dart';

@injectable
class RealFlutter {
  final Logger _logger;

  RealFlutter(this._logger);

  void doSomething() {
    _logger.log('Doing something');
  }
}

// logger.dart
class Logger {
  void log(String message) {
    print(message);
  }
}
```

// The application flow is as follows:
// 1. The main function is called, which creates an instance of the Logger class.
// 2. The Logger instance is injected into the RealFlutter class using the inject_annotation package.
// 3. The RealFlutter instance is created with the injected Logger instance.
// 4. The RealFlutter instance is used to call the doSomething method.
// 5. The doSomething method logs a message using the Logger instance.
// 6. The Flutter app is run using the runApp function.
// 7. The MyApp widget is built and displayed on the screen.

<-- END_MAIN -->