# json_convert Flutter Package

<!-- START_DESCRIPTION -->
## Description

The `json_convert` package is a powerful tool for Flutter developers that simplifies the process of converting JSON data into Dart objects and vice versa. This package is particularly useful when working with APIs that return JSON responses, allowing developers to easily parse and serialize data without writing extensive boilerplate code.

### When to Use

You should consider using the `json_convert` package when:
- You are working with RESTful APIs that return JSON data.
- You want to reduce the amount of manual serialization and deserialization code in your Flutter application.
- You need a straightforward way to map JSON data to Dart objects and vice versa.

### Features

- **Automatic Serialization**: Automatically converts JSON data into Dart objects.
- **Customizable Mappings**: Allows for custom mapping of JSON keys to Dart object properties.
- **Type Safety**: Ensures type safety when converting between JSON and Dart objects.
- **Support for Nested Objects**: Handles nested JSON structures seamlessly.

<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
## Tutorial

### Installation

To use the `json_convert` package in your Flutter project, you need to add it to your `pubspec.yaml` file. Open the file and add the following line under dependencies:

```yaml
dependencies:
  json_convert: ^latest_version
```

Replace `latest_version` with the most recent version of the package. After saving the file, run the following command in your terminal to install the package:

```bash
flutter pub get
```

### Platform-Specific Details

The `json_convert` package is designed to work seamlessly on both Android and iOS platforms. There are no specific platform configurations required for this package. However, ensure that your Flutter environment is set up correctly for both platforms.

### Basic Configuration

Once the package is installed, you can start using it in your Dart files. Import the package at the top of your Dart file:

```dart
import 'package:json_convert/json_convert.dart';
```

Now you are ready to use the package for JSON serialization and deserialization.

<!-- END_TUTORIAL -->

<!-- START_MAIN -->
## Complete Example

Here is a complete example demonstrating how to use the `json_convert` package in a Flutter application. This example includes a simple API call that fetches user data and displays it in a list.

```dart
import 'package:flutter/material.dart';
import 'package:json_convert/json_convert.dart'; // Importing the json_convert package
import 'dart:convert'; // Importing dart:convert for JSON handling
import 'package:http/http.dart' as http; // Importing http package for API calls

// Defining the RealFlutter class
class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'JSON Convert Example',
      home: UserListScreen(), // Setting the home screen to UserListScreen
    );
  }
}

// User model class
class User {
  final int id;
  final String name;
  final String email;

  User({required this.id, required this.name, required this.email});

  // Factory method to create a User from JSON
  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'],
      name: json['name'],
      email: json['email'],
    );
  }

  // Method to convert User to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'email': email,
    };
  }
}

// UserListScreen widget to display the list of users
class UserListScreen extends StatefulWidget {
  @override
  _UserListScreenState createState() => _UserListScreenState();
}

class _UserListScreenState extends State<UserListScreen> {
  List<User> users = []; // List to hold User objects

  @override
  void initState() {
    super.initState();
    fetchUsers(); // Fetch users when the widget is initialized
  }

  // Function to fetch users from the API
  Future<void> fetchUsers() async {
    final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/users'));

    if (response.statusCode == 200) {
      // If the server returns a 200 OK response, parse the JSON
      List<dynamic> jsonResponse = json.decode(response.body);
      setState(() {
        users = jsonResponse.map((user) => User.fromJson(user)).toList(); // Convert JSON to User objects
      });
    } else {
      throw Exception('Failed to load users'); // Handle error
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Users List'), // AppBar title
      ),
      body: ListView.builder(
        itemCount: users.length, // Number of users
        itemBuilder: (context, index) {
          return ListTile(
            title: Text(users[index].name), // Display user name
            subtitle: Text(users[index].email), // Display user email
          );
        },
      ),
    );
  }
}

// Main function to run the app
void main() {
  runApp(RealFlutter()); // Running the RealFlutter app
}

/*
Application Flow Explanation:
1. The app starts with the main function, which runs the RealFlutter widget.
2. The RealFlutter widget sets up the MaterialApp and specifies UserListScreen as the home screen.
3. UserListScreen is a stateful widget that initializes an empty list of users.
4. In the initState method, fetchUsers is called to retrieve user data from the API.
5. The fetchUsers function makes an HTTP GET request to the JSONPlaceholder API.
6. If the response is successful (status code 200), the JSON data is parsed into a list of User objects.
7. The state is updated with the list of users, triggering a rebuild of the widget.
8. The build method constructs a ListView to display the user names and emails.
9. Each user is displayed as a ListTile in the ListView.
*/
```

<!-- END_MAIN -->

## Summary

In this example, we demonstrated how to use the `json_convert` package to simplify the process of converting JSON data into Dart objects. The application fetches user data from a public API and displays it in a list format. The flow of the application is straightforward, with clear separation of concerns between data fetching, model representation, and UI rendering. This approach not only enhances code readability but also reduces the likelihood of errors during data conversion.