<-- START_DESCRIPTION -->

# Riverpod Infinite Scroll Package
=====================================

The `riverpod_infinite_scroll` package is a powerful tool for building infinite scrolling lists in Flutter applications. It provides a simple and efficient way to load and display large datasets, making it perfect for applications that require a seamless user experience.

### When to Use This Package

This package is ideal for applications that require infinite scrolling lists, such as:

* Social media feeds
* News articles
* Product lists
* Search results

### Features

* Infinite scrolling list
* Automatic loading of new data when the user reaches the end of the list
* Customizable loading indicators
* Support for pagination
* Works with any data source (e.g., API, database, etc.)

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up the Package
==========================

To use the `riverpod_infinite_scroll` package, follow these steps:

### Step 1: Add the Package to Your Pubspec.yaml File

```yml
dependencies:
  flutter:
    sdk: flutter
  riverpod_infinite_scroll: ^1.0.0
```

### Step 2: Import the Package in Your Dart File

```dart
import 'package:riverpod_infinite_scroll/riverpod_infinite_scroll.dart';
```

### Step 3: Create a Riverpod Provider

```dart
final riverpodProvider = RiverpodProvider((ref) {
  return YourDataProvider(); // Replace with your data provider
});
```

### Step 4: Wrap Your App with the RiverpodProvider

```dart
void main() {
  runApp(
    RiverpodProviderScope(
      child: MyApp(),
    ),
  );
}
```

### Step 5: Use the InfiniteScrollWidget

```dart
class RealFlutter extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final dataProvider = ref.watch(riverpodProvider);
    return InfiniteScrollWidget(
      dataProvider: dataProvider,
      itemBuilder: (context, item) {
        // Return your widget here
      },
    );
  }
}
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:riverpod_infinite_scroll/riverpod_infinite_scroll.dart';

void main() {
  runApp(
    RiverpodProviderScope(
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Riverpod Infinite Scroll Demo',
      home: RealFlutter(),
    );
  }
}

class RealFlutter extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Step 1: Create a Riverpod provider
    final riverpodProvider = RiverpodProvider((ref) {
      return YourDataProvider(); // Replace with your data provider
    });

    // Step 2: Watch the Riverpod provider
    final dataProvider = ref.watch(riverpodProvider);

    // Step 3: Use the InfiniteScrollWidget
    return InfiniteScrollWidget(
      dataProvider: dataProvider,
      itemBuilder: (context, item) {
        // Step 4: Return your widget here
        return ListTile(
          title: Text(item.toString()),
        );
      },
    );
  }
}

// This is a sample data provider
class YourDataProvider extends DataProvider {
  @override
  Future<List> loadData(int page) async {
    // Replace with your data loading logic
    return List.generate(10, (index) => 'Item $index');
  }
}

// Application flow:
// 1. The app starts and the RiverpodProviderScope is created.
// 2. The RealFlutter widget is built and it watches the Riverpod provider.
// 3. The InfiniteScrollWidget is used to display the data.
// 4. When the user scrolls to the end of the list, the InfiniteScrollWidget loads more data.
// 5. The new data is displayed in the list.
```

// The application flow is as follows:
// 1. The RiverpodProviderScope is created and wraps the entire app.
// 2. The RealFlutter widget is built and it watches the Riverpod provider.
// 3. The InfiniteScrollWidget is used to display the data and it loads more data when the user scrolls to the end of the list.
// 4. The new data is displayed in the list.
// This creates an infinite scrolling list that loads more data as the user scrolls.

<-- END_MAIN -->