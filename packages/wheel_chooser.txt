<-- START_DESCRIPTION -->

# Wheel Chooser Flutter Package
================================

The `wheel_chooser` Flutter package is a customizable wheel picker for Flutter applications. It allows users to select values from a circular wheel, similar to the iOS UIPickerView or Android's NumberPicker.

## When to Use
--------------

Use the `wheel_chooser` package when you need to provide users with a visually appealing and interactive way to select values from a range or list. This package is particularly useful for applications that require users to input numerical values, such as dates, times, or quantities.

## Features
------------

*   Customizable wheel appearance and behavior
*   Support for multiple wheels
*   Ability to set initial values and ranges
*   Event callbacks for value changes

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Tutorial
==========

## Setup
--------

To use the `wheel_chooser` package, add it to your `pubspec.yaml` file:

```yml
dependencies:
  wheel_chooser: ^1.0.0
```

Then, run `flutter pub get` to install the package.

## Basic Usage
-------------

To use the `WheelChooser` widget, import the package and create a new instance:

```dart
import 'package:wheel_chooser/wheel_chooser.dart';

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  int _value = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: WheelChooser(
          minValue: 0,
          maxValue: 100,
          initialValue: _value,
          onChanged: (value) {
            setState(() {
              _value = value;
            });
          },
        ),
      ),
    );
  }
}
```

## Platform-Specific Details
---------------------------

The `wheel_chooser` package uses the `dart:ui` library to render the wheel. On Android, this requires the `flutter.embedded_views` package to be added to the `AndroidManifest.xml` file:

```xml
<application
  ...
  android:usesCleartextTraffic="true"
  android:requestLegacyExternalStorage="true"
  tools:overrideLibrary="io.flutter.embedding">
  ...
</application>
```

On iOS, no additional configuration is required.

## Optimizations
--------------

To improve performance, consider setting the `itemExtent` property to a fixed value. This will reduce the number of layout calculations required.

```dart
WheelChooser(
  ...
  itemExtent: 40,
)
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:wheel_chooser/wheel_chooser.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Wheel Chooser Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: RealFlutter(),
    );
  }
}

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  int _value = 0;

  @override
  Widget build(BuildContext context) {
    // Create a Scaffold to hold the WheelChooser
    return Scaffold(
      appBar: AppBar(
        title: Text('Wheel Chooser Demo'),
      ),
      body: Center(
        // Create a WheelChooser with a range of 0-100
        child: WheelChooser(
          minValue: 0,
          maxValue: 100,
          initialValue: _value,
          // Update the _value variable when the user selects a new value
          onChanged: (value) {
            setState(() {
              _value = value;
            });
          },
        ),
      ),
    );
  }
}

// The application flow is as follows:
// 1. The user launches the app and is presented with a WheelChooser.
// 2. The user selects a value from the WheelChooser.
// 3. The onChanged callback is triggered, updating the _value variable.
// 4. The UI is rebuilt to reflect the new value.
```

<-- END_MAIN -->