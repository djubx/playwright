Hereâ€™s a detailed technical blog on the `tcp_scanner` Flutter package, structured as requested.

<!-- START_DESCRIPTION -->
# TCP Scanner Flutter Package

The `tcp_scanner` package is a powerful tool for Flutter developers looking to implement TCP scanning capabilities in their applications. This package allows you to scan for open TCP ports on a specified host, making it useful for network diagnostics, security assessments, and various networking applications.

## When to Use This Package

You might consider using the `tcp_scanner` package in scenarios such as:
- **Network Security Audits**: To identify open ports on devices within a network.
- **Device Discovery**: To find devices connected to a local network.
- **Network Troubleshooting**: To diagnose connectivity issues by checking which ports are open on a server.

## Features

- **Port Scanning**: Scan a range of ports on a specified host.
- **Asynchronous Operations**: Non-blocking operations to ensure smooth user experience.
- **Customizable Timeout**: Set timeouts for port scanning to avoid long waits.
- **Error Handling**: Built-in error handling for network-related issues.

With these features, the `tcp_scanner` package provides a robust solution for any Flutter application that requires network scanning capabilities.

<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
# Tutorial: Setting Up and Using the TCP Scanner Package

## Step 1: Adding the Dependency

To get started, you need to add the `tcp_scanner` package to your Flutter project. Open your `pubspec.yaml` file and add the following line under dependencies:

```yaml
dependencies:
  tcp_scanner: ^1.0.0  # Check for the latest version on pub.dev
```

Then, run the following command to install the package:

```bash
flutter pub get
```

## Step 2: Platform-Specific Configuration

### Android

For Android, ensure that you have the necessary permissions in your `AndroidManifest.xml` file. Add the following lines within the `<manifest>` tag:

```xml
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
```

### iOS

For iOS, you need to add the following permissions in your `Info.plist` file:

```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```

## Step 3: Using the Package

Now that you have set up the package, you can start using it in your Flutter application. Below is a simple example of how to scan for open TCP ports.

1. Import the package in your Dart file:

```dart
import 'package:tcp_scanner/tcp_scanner.dart';
```

2. Create a function to perform the scan:

```dart
Future<void> scanPorts(String host, int startPort, int endPort) async {
  List<int> openPorts = await TcpScanner.scan(host, startPort, endPort);
  print('Open ports: $openPorts');
}
```

3. Call this function from your UI or any other part of your application.

With these steps, you can effectively set up and use the `tcp_scanner` package in your Flutter application.

<!-- END_TUTORIAL -->

<!-- START_MAIN -->
# Complete Example of TCP Scanner in Flutter

```dart
import 'package:flutter/material.dart';
import 'package:tcp_scanner/tcp_scanner.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'TCP Scanner',
      home: ScannerHome(),
    );
  }
}

class ScannerHome extends StatefulWidget {
  @override
  _ScannerHomeState createState() => _ScannerHomeState();
}

class _ScannerHomeState extends State<ScannerHome> {
  String _host = '192.168.1.1'; // Default host
  int _startPort = 1; // Starting port for scanning
  int _endPort = 1024; // Ending port for scanning
  List<int> _openPorts = []; // List to store open ports

  // Function to scan ports
  Future<void> _scanPorts() async {
    // Clear previous results
    setState(() {
      _openPorts.clear();
    });

    // Perform the port scan
    List<int> openPorts = await TcpScanner.scan(_host, _startPort, _endPort);
    
    // Update the state with the open ports
    setState(() {
      _openPorts = openPorts;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('TCP Scanner'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            TextField(
              decoration: InputDecoration(labelText: 'Host'),
              onChanged: (value) {
                _host = value; // Update host from user input
              },
            ),
            TextField(
              decoration: InputDecoration(labelText: 'Start Port'),
              keyboardType: TextInputType.number,
              onChanged: (value) {
                _startPort = int.tryParse(value) ?? 1; // Update start port
              },
            ),
            TextField(
              decoration: InputDecoration(labelText: 'End Port'),
              keyboardType: TextInputType.number,
              onChanged: (value) {
                _endPort = int.tryParse(value) ?? 1024; // Update end port
              },
            ),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: _scanPorts, // Trigger port scan
              child: Text('Scan Ports'),
            ),
            SizedBox(height: 20),
            Text('Open Ports: $_openPorts'), // Display open ports
          ],
        ),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the main function, which runs the RealFlutter widget.
// 2. RealFlutter sets up the MaterialApp and points to the ScannerHome widget.
// 3. ScannerHome is a stateful widget that maintains the state of the host, start port, end port, and open ports.
// 4. The user can input the host and port range in the text fields.
// 5. When the "Scan Ports" button is pressed, the _scanPorts function is called.
// 6. This function clears any previous results, performs the port scan using TcpScanner.scan, and updates the state with the open ports.
// 7. The open ports are displayed on the screen.
```

<!-- END_MAIN -->

In this blog, we explored the `tcp_scanner` Flutter package, detailing its features, setup process, and providing a complete example. The application allows users to input a host and a range of ports to scan, displaying the open ports found. This package is a valuable tool for developers needing to implement network scanning functionalities in their Flutter applications.