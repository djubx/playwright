# Exploring the tcp_tunnel Flutter Package

## <-- START_DESCRIPTION -->

### Description

The `tcp_tunnel` package is a powerful Flutter library designed to facilitate TCP tunneling in mobile applications. This package allows developers to create a secure tunnel for TCP connections, enabling communication between a client and a server over a secure channel. It is particularly useful in scenarios where direct access to a server is restricted or when you need to bypass firewalls.

### When to Use

You might consider using the `tcp_tunnel` package in the following scenarios:

- **Bypassing Firewalls**: When your application needs to connect to a server that is behind a firewall or NAT.
- **Secure Communication**: To ensure that data transmitted between the client and server is encrypted and secure.
- **Remote Access**: For applications that require remote access to services running on a server.

### Features

- **TCP Connection Management**: Handles the establishment and management of TCP connections.
- **Data Encryption**: Supports secure data transmission through encryption.
- **Cross-Platform Support**: Works seamlessly on both Android and iOS platforms.
- **Easy Integration**: Simple API that allows for quick integration into existing Flutter applications.

## <-- END_DESCRIPTION -->

## <-- START_TUTORIAL -->

### Tutorial

To get started with the `tcp_tunnel` package, follow these steps:

#### Step 1: Add Dependency

Add the `tcp_tunnel` package to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  tcp_tunnel: ^latest_version
```

Make sure to replace `^latest_version` with the latest version available on [pub.dev](https://pub.dev/packages/tcp_tunnel).

#### Step 2: Platform-Specific Configuration

**For Android:**

1. Open `android/app/build.gradle`.
2. Ensure that the `minSdkVersion` is set to at least 21:

```groovy
android {
    ...
    defaultConfig {
        ...
        minSdkVersion 21
        ...
    }
}
```

3. Add the necessary permissions in `AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.INTERNET"/>
```

**For iOS:**

1. Open `ios/Runner/Info.plist`.
2. Add the following permissions:

```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```

#### Step 3: Basic Usage

To use the `tcp_tunnel` package, you need to create an instance of the `RealFlutter` class and establish a connection. Below is a simple example of how to do this.

## <-- END_TUTORIAL -->

## <-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:tcp_tunnel/tcp_tunnel.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'TCP Tunnel Example',
      home: RealFlutter(),
    );
  }
}

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  // Declare a TcpTunnel instance
  TcpTunnel? _tcpTunnel;
  String _status = 'Disconnected';

  @override
  void initState() {
    super.initState();
    // Initialize the TCP tunnel
    _tcpTunnel = TcpTunnel(
      host: 'your.server.com', // Replace with your server address
      port: 1234, // Replace with your server port
    );
  }

  // Function to connect to the server
  void _connect() async {
    try {
      await _tcpTunnel!.connect();
      setState(() {
        _status = 'Connected';
      });
    } catch (e) {
      setState(() {
        _status = 'Connection Failed: $e';
      });
    }
  }

  // Function to disconnect from the server
  void _disconnect() async {
    await _tcpTunnel!.disconnect();
    setState(() {
      _status = 'Disconnected';
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('TCP Tunnel Example'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text('Status: $_status'), // Display connection status
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: _connect, // Connect button
              child: Text('Connect'),
            ),
            ElevatedButton(
              onPressed: _disconnect, // Disconnect button
              child: Text('Disconnect'),
            ),
          ],
        ),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the MyApp widget, which sets up the MaterialApp.
// 2. The RealFlutter widget is created, initializing the TcpTunnel instance with the server's host and port.
// 3. The user can connect to the server by pressing the "Connect" button, which calls the _connect method.
// 4. If the connection is successful, the status is updated to "Connected".
// 5. The user can disconnect by pressing the "Disconnect" button, which calls the _disconnect method.
// 6. The status is updated to "Disconnected" after the disconnection.
```

## <-- END_MAIN -->

### Summary

In this blog post, we explored the `tcp_tunnel` Flutter package, which provides a robust solution for establishing secure TCP connections in mobile applications. We covered the installation process, platform-specific configurations, and provided a complete example demonstrating how to connect and disconnect from a server. The application flow was explained step-by-step through comments in the code, making it easy to understand how to implement this package in your own projects. 

By leveraging the `tcp_tunnel` package, developers can enhance their applications with secure and reliable TCP communication capabilities.