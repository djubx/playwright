<-- START_DESCRIPTION -->

# Flutter Bloc Patterns Package
================================

The `flutter_bloc_patterns` package is a powerful tool for managing state and business logic in Flutter applications. It provides a set of pre-built widgets and utilities that make it easy to implement the BLoC (Business Logic Component) pattern in your app.

## When to Use This Package
---------------------------

This package is ideal for complex applications that require a robust and scalable architecture. It's particularly useful when you need to manage multiple states, handle asynchronous data, and decouple your business logic from your UI.

## Key Features
----------------

*   Pre-built widgets for handling loading, error, and success states
*   Support for asynchronous data handling
*   Decoupling of business logic from UI
*   Scalable and maintainable architecture

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up the Package
-------------------------

To use the `flutter_bloc_patterns` package, you'll need to add it to your `pubspec.yaml` file:

```yml
dependencies:
  flutter_bloc_patterns: ^1.0.0
```

Then, run `flutter pub get` to install the package.

## Platform-Specific Configurations
------------------------------------

### Android

No additional configurations are required for Android.

### iOS

No additional configurations are required for iOS.

## Using the Package
---------------------

To use the package, you'll need to create a BLoC class that extends the `Bloc` class:

```dart
class RealFlutterBloc extends Bloc<RealFlutterEvent, RealFlutterState> {
  @override
  RealFlutterState get initialState => RealFlutterInitialState();

  @override
  Stream<RealFlutterState> mapEventToState(RealFlutterEvent event) async* {
    // Handle events and yield states
  }
}
```

Then, you can use the `BlocBuilder` widget to build your UI based on the current state:

```dart
BlocBuilder<RealFlutterBloc, RealFlutterState>(
  builder: (context, state) {
    // Build UI based on state
  },
)
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_bloc_patterns/flutter_bloc_patterns.dart';

// Events
abstract class RealFlutterEvent {}

class LoadRealFlutterDataEvent extends RealFlutterEvent {}

// States
abstract class RealFlutterState {}

class RealFlutterInitialState extends RealFlutterState {}

class RealFlutterLoadingState extends RealFlutterState {}

class RealFlutterSuccessState extends RealFlutterState {
  final String data;

  RealFlutterSuccessState({required this.data});
}

class RealFlutterErrorState extends RealFlutterState {
  final String error;

  RealFlutterErrorState({required this.error});
}

// BLoC
class RealFlutterBloc extends Bloc<RealFlutterEvent, RealFlutterState> {
  @override
  RealFlutterState get initialState => RealFlutterInitialState();

  @override
  Stream<RealFlutterState> mapEventToState(RealFlutterEvent event) async* {
    if (event is LoadRealFlutterDataEvent) {
      yield RealFlutterLoadingState();
      try {
        // Simulate data loading
        await Future.delayed(Duration(seconds: 2));
        yield RealFlutterSuccessState(data: 'Loaded data');
      } catch (e) {
        yield RealFlutterErrorState(error: e.toString());
      }
    }
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: BlocProvider<RealFlutterBloc>(
        create: (context) => RealFlutterBloc(),
        child: MyHomePage(),
      ),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Flutter BLoC Patterns'),
      ),
      body: BlocBuilder<RealFlutterBloc, RealFlutterState>(
        builder: (context, state) {
          if (state is RealFlutterInitialState) {
            // Initial state, load data
            context.read<RealFlutterBloc>().add(LoadRealFlutterDataEvent());
            return Center(
              child: Text('Loading...'),
            );
          } else if (state is RealFlutterLoadingState) {
            // Loading state, show progress indicator
            return Center(
              child: CircularProgressIndicator(),
            );
          } else if (state is RealFlutterSuccessState) {
            // Success state, show loaded data
            return Center(
              child: Text(state.data),
            );
          } else if (state is RealFlutterErrorState) {
            // Error state, show error message
            return Center(
              child: Text(state.error),
            );
          } else {
            // Unknown state, show error message
            return Center(
              child: Text('Unknown state'),
            );
          }
        },
      ),
    );
  }
}

// Application flow:
// 1. The app starts and the `MyApp` widget is built.
// 2. The `MyApp` widget creates a `RealFlutterBloc` instance and provides it to the `MyHomePage` widget.
// 3. The `MyHomePage` widget builds the UI based on the current state.
// 4. The initial state is `RealFlutterInitialState`, so the app loads the data by adding a `LoadRealFlutterDataEvent` to the BLoC.
// 5. The BLoC handles the event and yields a `RealFlutterLoadingState`.
// 6. The `MyHomePage` widget rebuilds the UI based on the new state and shows a progress indicator.
// 7. The BLoC finishes loading the data and yields a `RealFlutterSuccessState`.
// 8. The `MyHomePage` widget rebuilds the UI based on the new state and shows the loaded data.

```

<-- END_MAIN -->