```markdown
<!-- START_DESCRIPTION -->
# Cancellation Token HOC081098 Flutter Package

The `cancellation_token_hoc081098` package is a powerful tool for managing cancellation tokens in Flutter applications. It allows developers to create cancellable asynchronous operations, which can be particularly useful in scenarios where you want to prevent unnecessary work or resource usage, such as when a user navigates away from a screen or cancels a request.

## When to Use This Package
- **Network Requests**: Cancel ongoing HTTP requests when the user navigates away from a page.
- **Long-Running Tasks**: Stop background tasks that are no longer needed.
- **User Interactions**: Manage user-triggered actions that may need to be canceled based on user input.

## Key Features
- **Cancellable Operations**: Easily create and manage cancellation tokens for asynchronous tasks.
- **Integration with Future and Stream**: Works seamlessly with Dart's Future and Stream APIs.
- **Error Handling**: Provides a structured way to handle cancellations and errors.

This package is particularly useful in applications that require responsiveness and efficient resource management, making it a valuable addition to any Flutter developer's toolkit.
<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
# Tutorial: Setting Up and Using Cancellation Token HOC081098

## Installation
To add the `cancellation_token_hoc081098` package to your Flutter project, include it in your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  cancellation_token_hoc081098: ^1.0.0  # Check for the latest version on pub.dev
```

Run `flutter pub get` to install the package.

## Platform-Specific Details
### Android
No specific configurations are required for Android. Just ensure that your `minSdkVersion` is set appropriately in your `android/app/build.gradle` file.

### iOS
For iOS, ensure that your deployment target is set to at least 10.0 in your `ios/Podfile`.

## Basic Usage
To use the cancellation token, you will need to create an instance of `CancellationToken` and pass it to your asynchronous operations. Hereâ€™s a simple example:

```dart
import 'package:flutter/material.dart';
import 'package:cancellation_token_hoc081098/cancellation_token_hoc081098.dart';

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('Cancellation Token Example')),
        body: CancellationExample(),
      ),
    );
  }
}

class CancellationExample extends StatefulWidget {
  @override
  _CancellationExampleState createState() => _CancellationExampleState();
}

class _CancellationExampleState extends State<CancellationExample> {
  CancellationTokenSource? _cancellationTokenSource;

  @override
  void initState() {
    super.initState();
    _cancellationTokenSource = CancellationTokenSource();
  }

  @override
  void dispose() {
    _cancellationTokenSource?.cancel(); // Cancel any ongoing operations
    super.dispose();
  }

  void _startLongRunningTask() async {
    try {
      await Future.delayed(Duration(seconds: 5), () {
        if (_cancellationTokenSource!.token.isCancellationRequested) {
          throw Exception('Operation was cancelled');
        }
        // Simulate a long-running task
        print('Task completed');
      });
    } catch (e) {
      print(e); // Handle cancellation
    }
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: ElevatedButton(
        onPressed: _startLongRunningTask,
        child: Text('Start Task'),
      ),
    );
  }
}
```

In this example, we create a simple Flutter app that starts a long-running task when a button is pressed. If the task is still running when the widget is disposed, it will be canceled.

<!-- END_TUTORIAL -->

<!-- START_MAIN -->
# Complete Example of Cancellation Token HOC081098

```dart
import 'package:flutter/material.dart';
import 'package:cancellation_token_hoc081098/cancellation_token_hoc081098.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('Cancellation Token Example')),
        body: CancellationExample(),
      ),
    );
  }
}

class CancellationExample extends StatefulWidget {
  @override
  _CancellationExampleState createState() => _CancellationExampleState();
}

class _CancellationExampleState extends State<CancellationExample> {
  CancellationTokenSource? _cancellationTokenSource;

  @override
  void initState() {
    super.initState();
    _cancellationTokenSource = CancellationTokenSource(); // Initialize the cancellation token
  }

  @override
  void dispose() {
    _cancellationTokenSource?.cancel(); // Cancel any ongoing operations when the widget is disposed
    super.dispose();
  }

  void _startLongRunningTask() async {
    try {
      await Future.delayed(Duration(seconds: 5), () {
        // Check if cancellation has been requested
        if (_cancellationTokenSource!.token.isCancellationRequested) {
          throw Exception('Operation was cancelled'); // Throw an exception if cancelled
        }
        // Simulate a long-running task
        print('Task completed'); // Print task completion
      });
    } catch (e) {
      print(e); // Handle cancellation
    }
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: ElevatedButton(
        onPressed: _startLongRunningTask, // Start the long-running task on button press
        child: Text('Start Task'),
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the RealFlutter widget, which sets up the MaterialApp and Scaffold.
// 2. The CancellationExample widget is created, initializing a CancellationTokenSource.
// 3. When the button is pressed, the _startLongRunningTask method is called.
// 4. This method simulates a long-running task with a delay of 5 seconds.
// 5. If the widget is disposed before the task completes, the cancellation token is triggered, cancelling the operation.
// 6. If the task completes without cancellation, it prints 'Task completed' to the console.
// 7. If the task is cancelled, it throws an exception that is caught and printed.
```
<!-- END_MAIN -->
```

This structured blog post provides a comprehensive overview of the `cancellation_token_hoc081098` package, including its features, setup instructions, and a complete example with detailed comments explaining the application flow.