Here's a detailed technical blog on the "eval_ex" Flutter package, structured as requested.

<!-- START_DESCRIPTION -->
# Description

The `eval_ex` Flutter package is a powerful library that allows developers to evaluate mathematical expressions in Dart. This package is particularly useful in applications that require dynamic calculations, such as financial apps, scientific calculators, or any app that needs to process user-defined formulas.

## Features
- **Expression Evaluation**: Evaluate complex mathematical expressions at runtime.
- **Variable Support**: Use variables within expressions, allowing for dynamic calculations based on user input or application state.
- **Function Support**: Define and use custom functions within expressions.
- **Error Handling**: Provides robust error handling for invalid expressions.

## When to Use
You might consider using the `eval_ex` package in scenarios such as:
- Building a calculator app where users can input their own formulas.
- Creating a financial application that requires real-time calculations based on user-defined parameters.
- Developing educational tools that allow students to experiment with mathematical expressions.

<!-- END_DESCRIPTION -->

<!-- START_TUTORIAL -->
# Tutorial

## Setup Process

To get started with the `eval_ex` package, follow these steps:

1. **Add Dependency**: Open your `pubspec.yaml` file and add the `eval_ex` package under dependencies:

   ```yaml
   dependencies:
     flutter:
       sdk: flutter
     eval_ex: ^1.0.0  # Check for the latest version on pub.dev
   ```

2. **Install Packages**: Run the following command in your terminal to install the new dependency:

   ```bash
   flutter pub get
   ```

3. **Platform-Specific Configuration**:
   - **Android**: Ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 21.
   - **iOS**: No specific configurations are required for iOS, but ensure your deployment target is compatible.

4. **Import the Package**: In your Dart files, import the package:

   ```dart
   import 'package:eval_ex/eval_ex.dart';
   ```

## Basic Usage

Hereâ€™s how to use the `eval_ex` package in your Flutter application:

1. **Creating an Instance**: You can create an instance of the `Expression` class to evaluate expressions.

   ```dart
   var expression = Expression.parse("2 + 3 * (4 - 1)");
   var evaluator = const ExpressionEvaluator();
   var result = evaluator.eval(expression, null);
   print(result); // Outputs: 11
   ```

2. **Using Variables**: You can also evaluate expressions with variables:

   ```dart
   var variables = {'x': 10, 'y': 5};
   var expressionWithVars = Expression.parse("x + y * 2");
   var resultWithVars = evaluator.eval(expressionWithVars, variables);
   print(resultWithVars); // Outputs: 20
   ```

3. **Defining Functions**: You can define custom functions to use in your expressions:

   ```dart
   evaluator.addFunction('square', (num x) => x * x);
   var expressionWithFunction = Expression.parse("square(4) + 2");
   var resultWithFunction = evaluator.eval(expressionWithFunction, null);
   print(resultWithFunction); // Outputs: 18
   ```

By following these steps, you can effectively integrate the `eval_ex` package into your Flutter application and leverage its powerful expression evaluation capabilities.

<!-- END_TUTORIAL -->

<!-- START_MAIN -->
# Complete Example

```dart
import 'package:flutter/material.dart';
import 'package:eval_ex/eval_ex.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Eval Ex Example',
      home: Scaffold(
        appBar: AppBar(
          title: Text('Eval Ex Example'),
        ),
        body: ExpressionEvaluatorWidget(),
      ),
    );
  }
}

class ExpressionEvaluatorWidget extends StatefulWidget {
  @override
  _ExpressionEvaluatorWidgetState createState() => _ExpressionEvaluatorWidgetState();
}

class _ExpressionEvaluatorWidgetState extends State<ExpressionEvaluatorWidget> {
  final TextEditingController _controller = TextEditingController();
  String _result = '';

  void _evaluateExpression() {
    // Parse the expression from the input field
    var expression = Expression.parse(_controller.text);
    var evaluator = const ExpressionEvaluator();

    try {
      // Evaluate the expression with no variables
      var result = evaluator.eval(expression, null);
      setState(() {
        _result = 'Result: $result';
      });
    } catch (e) {
      // Handle any errors during evaluation
      setState(() {
        _result = 'Error: ${e.toString()}';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          TextField(
            controller: _controller,
            decoration: InputDecoration(
              labelText: 'Enter Expression',
              hintText: 'e.g., 2 + 3 * (4 - 1)',
            ),
          ),
          SizedBox(height: 20),
          ElevatedButton(
            onPressed: _evaluateExpression,
            child: Text('Evaluate'),
          ),
          SizedBox(height: 20),
          Text(_result, style: TextStyle(fontSize: 24)),
        ],
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the main function, which runs the RealFlutter widget.
// 2. RealFlutter builds a MaterialApp with a title and a home Scaffold.
// 3. The ExpressionEvaluatorWidget is displayed, which contains a TextField for user input.
// 4. When the user enters an expression and presses the 'Evaluate' button, the _evaluateExpression method is called.
// 5. This method parses the expression and evaluates it using the ExpressionEvaluator.
// 6. If the evaluation is successful, the result is displayed; otherwise, an error message is shown.
```

<!-- END_MAIN -->

In this blog, we explored the `eval_ex` Flutter package, detailing its features, setup process, and providing a complete example of its usage. The application allows users to input mathematical expressions, which are then evaluated dynamically, showcasing the package's capabilities in a practical context.