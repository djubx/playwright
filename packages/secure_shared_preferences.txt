```markdown
<-- START_DESCRIPTION -->

# Secure Shared Preferences in Flutter

The `secure_shared_preferences` package in Flutter is a powerful tool designed to store data securely on both Android and iOS platforms. It provides a simple API to store key-value pairs, similar to the standard `shared_preferences` package, but with added security features. This package is particularly useful when you need to store sensitive information such as authentication tokens, user credentials, or any other data that requires encryption.

## When to Use Secure Shared Preferences

- **Storing Sensitive Data**: Use this package when you need to store sensitive information securely on the device.
- **Cross-Platform Security**: It provides a consistent API for both Android and iOS, ensuring that your data is encrypted on both platforms.
- **Ease of Use**: The API is straightforward and easy to integrate into existing projects, making it a great choice for developers looking to enhance security without a steep learning curve.

## Features

- **Data Encryption**: Automatically encrypts data before storing it on the device.
- **Cross-Platform Support**: Works seamlessly on both Android and iOS.
- **Simple API**: Provides a simple and familiar API for developers who have used `shared_preferences`.

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Tutorial: Setting Up Secure Shared Preferences

In this section, we'll walk through the setup process for the `secure_shared_preferences` package and demonstrate how to use it in a Flutter application.

## Setup

### Adding the Dependency

First, add the `secure_shared_preferences` package to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  secure_shared_preferences: ^1.0.0
```

Run `flutter pub get` to install the package.

### Platform-Specific Configuration

#### Android

For Android, ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 18:

```gradle
android {
    defaultConfig {
        minSdkVersion 18
    }
}
```

#### iOS

For iOS, no additional configuration is required. The package uses the Keychain services to store data securely.

## Using Secure Shared Preferences

Here's how you can use the package in your Flutter application:

1. **Import the Package**: Start by importing the package in your Dart file.

   ```dart
   import 'package:secure_shared_preferences/secure_shared_preferences.dart';
   ```

2. **Initialize the Preferences**: Create an instance of `SecureSharedPreferences`.

   ```dart
   final prefs = await SecureSharedPreferences.getInstance();
   ```

3. **Storing Data**: Use the `setString`, `setInt`, etc., methods to store data securely.

   ```dart
   await prefs.setString('key', 'value');
   ```

4. **Retrieving Data**: Use the `getString`, `getInt`, etc., methods to retrieve data.

   ```dart
   String value = await prefs.getString('key');
   ```

<-- END_TUTORIAL -->

<-- START_MAIN -->

# Complete Example: Secure Shared Preferences in Action

Below is a complete example of a Flutter application using the `secure_shared_preferences` package. This example demonstrates how to store and retrieve a string securely.

```dart
import 'package:flutter/material.dart';
import 'package:secure_shared_preferences/secure_shared_preferences.dart';

void main() {
  runApp(RealFlutterApp());
}

class RealFlutterApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Secure Shared Preferences Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: SecurePreferencesDemo(),
    );
  }
}

class SecurePreferencesDemo extends StatefulWidget {
  @override
  _SecurePreferencesDemoState createState() => _SecurePreferencesDemoState();
}

class _SecurePreferencesDemoState extends State<SecurePreferencesDemo> {
  final TextEditingController _controller = TextEditingController();
  String _storedValue = '';

  @override
  void initState() {
    super.initState();
    _loadStoredValue();
  }

  // Load the stored value from secure preferences
  Future<void> _loadStoredValue() async {
    final prefs = await SecureSharedPreferences.getInstance();
    String value = await prefs.getString('secureKey') ?? 'No value stored';
    setState(() {
      _storedValue = value;
    });
  }

  // Save the value to secure preferences
  Future<void> _saveValue() async {
    final prefs = await SecureSharedPreferences.getInstance();
    await prefs.setString('secureKey', _controller.text);
    _loadStoredValue(); // Refresh the displayed value
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Secure Shared Preferences'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: <Widget>[
            TextField(
              controller: _controller,
              decoration: InputDecoration(labelText: 'Enter a value'),
            ),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: _saveValue,
              child: Text('Save Value'),
            ),
            SizedBox(height: 20),
            Text('Stored Value: $_storedValue'),
          ],
        ),
      ),
    );
  }
}
```

// The application starts by running the `RealFlutterApp` class, which sets up the MaterialApp.
// The home screen is set to `SecurePreferencesDemo`, a stateful widget that manages the secure storage.
// In `initState`, the app loads any previously stored value using `_loadStoredValue`.
// The `_loadStoredValue` method retrieves the stored string from secure preferences and updates the UI.
// The `_saveValue` method saves the input from the text field to secure preferences and refreshes the displayed value.
// The UI consists of a text field for input, a button to save the input, and a text widget to display the stored value.

<-- END_MAIN -->
```