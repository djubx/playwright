# Flutter Storyblok Package: A Comprehensive Guide

## <-- START_DESCRIPTION -->

### Description

The `flutter_storyblok` package is a powerful tool that integrates the Storyblok headless CMS with Flutter applications. It allows developers to fetch and display content dynamically, making it an excellent choice for projects that require a flexible content management system. With Storyblok, you can manage your content in a user-friendly interface while delivering it seamlessly to your Flutter app.

### When to Use

You should consider using `flutter_storyblok` when:
- You need a headless CMS to manage content for your Flutter application.
- Your project requires dynamic content updates without redeploying the app.
- You want to leverage Storyblok's visual editor for non-technical team members to manage content.

### Features

- **Dynamic Content Fetching**: Easily fetch content from Storyblok's API.
- **Real-time Updates**: Automatically update content in your app when changes are made in Storyblok.
- **Custom Components**: Create reusable components that can be managed through Storyblok.
- **Rich Text Support**: Handle rich text content seamlessly.
- **Localization**: Support for multiple languages and locales.

## <-- END_DESCRIPTION -->

## <-- START_TUTORIAL -->

### Tutorial

#### Installation

To get started with the `flutter_storyblok` package, you need to add it to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_storyblok: ^latest_version
```

Make sure to replace `^latest_version` with the latest version available on [pub.dev](https://pub.dev/packages/flutter_storyblok).

#### Platform-Specific Configuration

**For Android:**
1. Ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 21.
2. Add internet permissions in `AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.INTERNET"/>
```

**For iOS:**
1. Open `ios/Runner/Info.plist` and add the following lines to allow network requests:

```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```

#### Basic Usage

1. Import the package in your Dart file:

```dart
import 'package:flutter_storyblok/flutter_storyblok.dart';
```

2. Initialize the Storyblok client with your API key:

```dart
final storyblok = StoryblokClient(
  accessToken: 'your_access_token',
);
```

3. Fetch content from Storyblok:

```dart
void fetchContent() async {
  final response = await storyblok.getStory('your_story_slug');
  // Handle the response
}
```

4. Display the content in your Flutter widgets.

## <-- END_TUTORIAL -->

## <-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:flutter_storyblok/flutter_storyblok.dart';

void main() {
  runApp(RealFlutter());
}

class RealFlutter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Storyblok Example',
      home: StoryblokHome(),
    );
  }
}

class StoryblokHome extends StatefulWidget {
  @override
  _StoryblokHomeState createState() => _StoryblokHomeState();
}

class _StoryblokHomeState extends State<StoryblokHome> {
  late StoryblokClient storyblok;
  late Future<Story> story;

  @override
  void initState() {
    super.initState();
    // Initialize the Storyblok client with your access token
    storyblok = StoryblokClient(accessToken: 'your_access_token');
    // Fetch the story from Storyblok
    story = fetchStory();
  }

  Future<Story> fetchStory() async {
    // Fetch the story using the slug
    final response = await storyblok.getStory('your_story_slug');
    return response.story;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Storyblok Content'),
      ),
      body: FutureBuilder<Story>(
        future: story,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            // Show a loading indicator while fetching data
            return Center(child: CircularProgressIndicator());
          } else if (snapshot.hasError) {
            // Handle error case
            return Center(child: Text('Error: ${snapshot.error}'));
          } else {
            // Display the fetched story content
            return Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(snapshot.data!.content['text'] ?? 'No content available'),
            );
          }
        },
      ),
    );
  }
}

// Application Flow Explanation:
// 1. The app starts with the main function, which runs the RealFlutter widget.
// 2. RealFlutter sets up a MaterialApp with a title and home widget (StoryblokHome).
// 3. In StoryblokHome, we initialize the Storyblok client with an access token.
// 4. We fetch the story from Storyblok in the initState method and store it in a Future variable.
// 5. The build method uses a FutureBuilder to handle the asynchronous fetching of the story.
// 6. While the story is being fetched, a loading indicator is displayed.
// 7. If an error occurs during fetching, an error message is shown.
// 8. Once the story is successfully fetched, its content is displayed in a Text widget.
```

## <-- END_MAIN -->

### Summary

In this blog post, we explored the `flutter_storyblok` package, which allows Flutter developers to integrate Storyblok's headless CMS into their applications. We covered the installation process, platform-specific configurations, and provided a complete example of a Flutter app that fetches and displays content from Storyblok. The application flow was explained step-by-step through comments in the code, making it easy to understand how to implement this package in your own projects. With its dynamic content capabilities and user-friendly interface, `flutter_storyblok` is a valuable tool for any Flutter developer looking to manage content effectively.