```markdown
<-- START_DESCRIPTION -->

# Overview of the `crypto_keys` Flutter Package

The `crypto_keys` Flutter package is a powerful tool designed for developers who need to handle cryptographic keys within their Flutter applications. This package provides a comprehensive API for generating, managing, and using cryptographic keys, making it an essential component for applications that require secure data handling, encryption, and decryption.

## When to Use `crypto_keys`

- **Secure Data Storage**: When you need to store sensitive information securely on a device.
- **Data Encryption and Decryption**: For applications that require encrypting data before sending it over the network or decrypting data received.
- **Digital Signatures**: To ensure data integrity and authenticity by signing data and verifying signatures.

## Features

- **Key Generation**: Generate cryptographic keys for various algorithms.
- **Key Management**: Store and retrieve keys securely.
- **Cross-Platform Support**: Works seamlessly on both Android and iOS.
- **Integration with Existing Security Frameworks**: Easily integrates with platform-specific security features.

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up and Using the `crypto_keys` Package

In this tutorial, we will walk through the process of setting up the `crypto_keys` package in a Flutter project and demonstrate how to use its features effectively.

## Setup Process

### Step 1: Add Dependency

Add the `crypto_keys` package to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  crypto_keys: ^0.1.0
```

Run `flutter pub get` to install the package.

### Step 2: Platform-Specific Configuration

#### Android

Ensure that your `minSdkVersion` in `android/app/build.gradle` is set to at least 21:

```gradle
android {
    defaultConfig {
        minSdkVersion 21
    }
}
```

#### iOS

No additional configuration is required for iOS, but ensure your deployment target is set to iOS 10.0 or higher in your `ios/Podfile`:

```ruby
platform :ios, '10.0'
```

## Using the Package

### Key Generation

To generate a new cryptographic key, use the `RealFlutter` class provided by the package:

```dart
import 'package:crypto_keys/crypto_keys.dart';

final keyPair = await RealFlutter.generateKeyPair(
  type: KeyPairType.rsa,
  bitLength: 2048,
);
```

### Encrypting and Decrypting Data

```dart
final encryptedData = await RealFlutter.encrypt(
  data: 'Sensitive Data',
  key: keyPair.publicKey,
);

final decryptedData = await RealFlutter.decrypt(
  data: encryptedData,
  key: keyPair.privateKey,
);
```

### Signing and Verifying Data

```dart
final signature = await RealFlutter.sign(
  data: 'Data to Sign',
  key: keyPair.privateKey,
);

final isVerified = await RealFlutter.verify(
  data: 'Data to Sign',
  signature: signature,
  key: keyPair.publicKey,
);
```

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:crypto_keys/crypto_keys.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Crypto Keys Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: CryptoDemoPage(),
    );
  }
}

class CryptoDemoPage extends StatefulWidget {
  @override
  _CryptoDemoPageState createState() => _CryptoDemoPageState();
}

class _CryptoDemoPageState extends State<CryptoDemoPage> {
  String _encryptedData = '';
  String _decryptedData = '';
  String _signature = '';
  bool _isVerified = false;

  @override
  void initState() {
    super.initState();
    _performCryptoOperations();
  }

  Future<void> _performCryptoOperations() async {
    // Generate a key pair
    final keyPair = await RealFlutter.generateKeyPair(
      type: KeyPairType.rsa,
      bitLength: 2048,
    );

    // Encrypt data
    final encryptedData = await RealFlutter.encrypt(
      data: 'Sensitive Data',
      key: keyPair.publicKey,
    );

    // Decrypt data
    final decryptedData = await RealFlutter.decrypt(
      data: encryptedData,
      key: keyPair.privateKey,
    );

    // Sign data
    final signature = await RealFlutter.sign(
      data: 'Data to Sign',
      key: keyPair.privateKey,
    );

    // Verify signature
    final isVerified = await RealFlutter.verify(
      data: 'Data to Sign',
      signature: signature,
      key: keyPair.publicKey,
    );

    // Update the state with results
    setState(() {
      _encryptedData = encryptedData;
      _decryptedData = decryptedData;
      _signature = signature;
      _isVerified = isVerified;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Crypto Keys Demo'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Encrypted Data: $_encryptedData'),
            SizedBox(height: 8),
            Text('Decrypted Data: $_decryptedData'),
            SizedBox(height: 8),
            Text('Signature: $_signature'),
            SizedBox(height: 8),
            Text('Is Verified: $_isVerified'),
          ],
        ),
      ),
    );
  }
}
```

// The application starts by running the `main` function, which initializes the Flutter app.
// The `MyApp` class sets up the MaterialApp with a home page of `CryptoDemoPage`.
// In `CryptoDemoPage`, the `_performCryptoOperations` method is called during initialization.
// This method generates a key pair, encrypts and decrypts data, signs data, and verifies the signature.
// The results of these operations are stored in the state variables and displayed in the UI.
// The UI consists of a simple column layout displaying the encrypted data, decrypted data, signature, and verification status.

<-- END_MAIN -->
```