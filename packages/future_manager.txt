<-- START_DESCRIPTION -->

# Future Manager Package
The Future Manager package is a utility package for Flutter that helps manage futures and callbacks in a more efficient and organized way. It provides a simple and intuitive API for handling asynchronous operations, making it easier to write clean and maintainable code.

## When to Use
The Future Manager package is useful when you need to handle multiple asynchronous operations in your Flutter app, such as:

* Making API calls to a server
* Reading or writing data to a database
* Performing file I/O operations
* Handling user input and validation

## Features
The Future Manager package provides the following features:

* A simple and intuitive API for handling futures and callbacks
* Support for handling multiple asynchronous operations concurrently
* Automatic error handling and propagation
* Support for canceling ongoing operations

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up the Future Manager Package
To use the Future Manager package in your Flutter app, follow these steps:

1. Add the package to your `pubspec.yaml` file:
```yml
dependencies:
  future_manager: ^1.0.0
```
2. Run `flutter pub get` to install the package.
3. Import the package in your Dart file:
```dart
import 'package:future_manager/future_manager.dart';
```
## Platform-Specific Details
The Future Manager package works on both Android and iOS platforms. However, there are some platform-specific details to keep in mind:

* On Android, the package uses the `android.os.AsyncTask` class to handle asynchronous operations.
* On iOS, the package uses the `dispatch_async` function to handle asynchronous operations.

## Configurations and Optimizations
To optimize the performance of the Future Manager package, you can configure the following settings:

* `maxConcurrentTasks`: The maximum number of concurrent tasks that can be executed at the same time. Default value is 5.
* `taskTimeout`: The timeout duration for each task. Default value is 30 seconds.

You can configure these settings by creating a `FutureManagerConfig` object and passing it to the `FutureManager` constructor:
```dart
FutureManagerConfig config = FutureManagerConfig(
  maxConcurrentTasks: 10,
  taskTimeout: Duration(seconds: 60),
);

FutureManager futureManager = FutureManager(config);
```
<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:future_manager/future_manager.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Future Manager Demo',
      home: FutureManagerDemo(),
    );
  }
}

class FutureManagerDemo extends StatefulWidget {
  @override
  _FutureManagerDemoState createState() => _FutureManagerDemoState();
}

class _FutureManagerDemoState extends State<FutureManagerDemo> {
  FutureManager _futureManager;

  @override
  void initState() {
    super.initState();
    _futureManager = FutureManager();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Future Manager Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              onPressed: _performAsyncOperation,
              child: Text('Perform Async Operation'),
            ),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: _cancelAsyncOperation,
              child: Text('Cancel Async Operation'),
            ),
          ],
        ),
      ),
    );
  }

  void _performAsyncOperation() {
    // Create a future that simulates an async operation
    Future<String> future = Future.delayed(Duration(seconds: 5), () {
      return 'Async operation completed';
    });

    // Use the FutureManager to handle the future
    _futureManager.handleFuture(future, (result) {
      print(result);
    }, (error) {
      print(error);
    });
  }

  void _cancelAsyncOperation() {
    // Cancel the ongoing async operation
    _futureManager.cancel();
  }
}

// The application flow is as follows:
// 1. The user clicks the "Perform Async Operation" button, which calls the _performAsyncOperation method.
// 2. The _performAsyncOperation method creates a future that simulates an async operation.
// 3. The future is passed to the FutureManager, which handles the future and executes the async operation.
// 4. When the async operation is completed, the FutureManager calls the callback function with the result.
// 5. If the user clicks the "Cancel Async Operation" button, the _cancelAsyncOperation method is called.
// 6. The _cancelAsyncOperation method cancels the ongoing async operation using the FutureManager.
```

// The FutureManager package simplifies the process of handling futures and callbacks in Flutter.
// It provides a simple and intuitive API for handling asynchronous operations, making it easier to write clean and maintainable code.
// The package also supports canceling ongoing operations, which is useful in scenarios where the user needs to interrupt an async operation.
// Overall, the FutureManager package is a useful utility for Flutter developers who need to handle asynchronous operations in their apps.

<-- END_MAIN -->