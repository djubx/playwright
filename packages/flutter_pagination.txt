<-- START_DESCRIPTION -->

# Flutter Pagination Package
================================

The `flutter_pagination` package provides a simple and efficient way to implement pagination in Flutter applications. Pagination is a common technique used to improve the performance of applications by loading data in chunks, rather than all at once.

## When to Use
--------------

You should use this package when:

* You have a large dataset that needs to be displayed in a list or grid.
* You want to improve the performance of your application by reducing the amount of data loaded at once.
* You need to implement pagination in your application, but don't want to handle the complexities of pagination yourself.

## Features
------------

The `flutter_pagination` package provides the following features:

* Support for both finite and infinite pagination.
* Customizable pagination controls, including buttons and indicators.
* Support for loading data from a variety of sources, including APIs and databases.
* Automatic handling of pagination logic, including calculating page numbers and loading data.

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Tutorial
==========

## Setup
--------

To use the `flutter_pagination` package, you need to add it to your project's `pubspec.yaml` file:

```yml
dependencies:
  flutter_pagination: ^1.0.0
```

Then, run `flutter pub get` to install the package.

## Basic Usage
-------------

To use the package, you need to create a `PaginationController` and pass it to a `PaginationView`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_pagination/flutter_pagination.dart';

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  final PaginationController _controller = PaginationController();

  @override
  Widget build(BuildContext context) {
    return PaginationView(
      controller: _controller,
      itemBuilder: (context, index) {
        return ListTile(
          title: Text('Item $index'),
        );
      },
      onPageChanged: (page) {
        // Load data for the new page
      },
    );
  }
}
```

## Customization
--------------

You can customize the pagination controls by passing a `PaginationControls` widget to the `PaginationView`:

```dart
PaginationView(
  controller: _controller,
  itemBuilder: (context, index) {
    return ListTile(
      title: Text('Item $index'),
    );
  },
  onPageChanged: (page) {
    // Load data for the new page
  },
  controls: PaginationControls(
    buttons: [
      PaginationButton(
        onPressed: () {
          _controller.previousPage();
        },
        child: Text('Previous'),
      ),
      PaginationButton(
        onPressed: () {
          _controller.nextPage();
        },
        child: Text('Next'),
      ),
    ],
  ),
)
```

## Platform-Specific Details
---------------------------

The package uses the `Scrollable` widget to handle pagination, which means it works seamlessly on both Android and iOS.

However, if you need to customize the pagination controls, you may need to use platform-specific widgets. For example, on Android, you can use the `MaterialButton` widget, while on iOS, you can use the `CupertinoButton` widget.

<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:flutter_pagination/flutter_pagination.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Pagination Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: RealFlutter(),
    );
  }
}

class RealFlutter extends StatefulWidget {
  @override
  _RealFlutterState createState() => _RealFlutterState();
}

class _RealFlutterState extends State<RealFlutter> {
  final PaginationController _controller = PaginationController();
  List<String> _data = [];

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Flutter Pagination Demo'),
      ),
      body: PaginationView(
        controller: _controller,
        itemBuilder: (context, index) {
          return ListTile(
            title: Text(_data[index]),
          );
        },
        onPageChanged: (page) {
          _loadData();
        },
        controls: PaginationControls(
          buttons: [
            PaginationButton(
              onPressed: () {
                _controller.previousPage();
              },
              child: Text('Previous'),
            ),
            PaginationButton(
              onPressed: () {
                _controller.nextPage();
              },
              child: Text('Next'),
            ),
          ],
        ),
      ),
    );
  }

  void _loadData() {
    // Simulate loading data from an API or database
    Future.delayed(Duration(seconds: 2), () {
      setState(() {
        _data = List.generate(10, (index) => 'Item $index');
      });
    });
  }
}

// The application flow is as follows:
// 1. The user opens the app and the `RealFlutter` widget is displayed.
// 2. The `_loadData` function is called to simulate loading data from an API or database.
// 3. The data is displayed in the `PaginationView` widget.
// 4. The user can navigate to the next or previous page using the pagination controls.
// 5. When the user navigates to a new page, the `_loadData` function is called again to simulate loading data for the new page.
// 6. The data for the new page is displayed in the `PaginationView` widget.

// In summary, the code flows as follows:
// - The user opens the app and the `RealFlutter` widget is displayed.
// - The `_loadData` function is called to simulate loading data from an API or database.
// - The data is displayed in the `PaginationView` widget.
// - The user can navigate to the next or previous page using the pagination controls.
// - When the user navigates to a new page, the `_loadData` function is called again to simulate loading data for the new page.

<-- END_MAIN -->