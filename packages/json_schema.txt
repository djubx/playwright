<-- START_DESCRIPTION -->

# json_schema Flutter Package
The `json_schema` package is a powerful tool for validating and generating JSON data in Flutter applications. It provides a simple and efficient way to ensure that your JSON data conforms to a specific schema, which is essential for maintaining data consistency and preventing errors.

## When to Use
You should use the `json_schema` package in the following scenarios:

* When working with APIs that require specific JSON data formats
* When generating JSON data that needs to conform to a specific schema
* When validating user input data that needs to match a specific JSON schema

## Features
The `json_schema` package provides the following features:

* JSON schema validation
* JSON data generation
* Support for complex JSON schema definitions
* Customizable validation rules

<-- END_DESCRIPTION -->

<-- START_TUTORIAL -->

# Setting Up the json_schema Package
To use the `json_schema` package in your Flutter application, follow these steps:

1. Add the `json_schema` package to your `pubspec.yaml` file:
```yml
dependencies:
  json_schema: ^1.0.0
```
2. Run `flutter pub get` to install the package.
3. Import the `json_schema` package in your Dart file:
```dart
import 'package:json_schema/json_schema.dart';
```
## Platform-Specific Details
The `json_schema` package works on both Android and iOS platforms. However, if you're using a specific platform's native JSON parsing library, you may need to configure the package accordingly.

For example, on Android, you can use the `json_schema` package with the `json` library:
```dart
import 'package:json/json.dart';

void main() {
  final jsonSchema = JsonSchema.fromJson({
    'type': 'object',
    'properties': {
      'name': {'type': 'string'},
      'age': {'type': 'integer'},
    },
  });

  final jsonData = {
    'name': 'John Doe',
    'age': 30,
  };

  final validationErrors = jsonSchema.validate(jsonData);
  if (validationErrors.isEmpty) {
    print('JSON data is valid!');
  } else {
    print('JSON data is invalid: $validationErrors');
  }
}
```
On iOS, you can use the `json_schema` package with the `json` library:
```dart
import 'package:json/json.dart';

void main() {
  final jsonSchema = JsonSchema.fromJson({
    'type': 'object',
    'properties': {
      'name': {'type': 'string'},
      'age': {'type': 'integer'},
    },
  });

  final jsonData = {
    'name': 'John Doe',
    'age': 30,
  };

  final validationErrors = jsonSchema.validate(jsonData);
  if (validationErrors.isEmpty) {
    print('JSON data is valid!');
  } else {
    print('JSON data is invalid: $validationErrors');
  }
}
```
<-- END_TUTORIAL -->

<-- START_MAIN -->

```dart
import 'package:flutter/material.dart';
import 'package:json_schema/json_schema.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'JSON Schema Demo',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _ageController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('JSON Schema Demo'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              TextFormField(
                controller: _nameController,
                decoration: InputDecoration(
                  labelText: 'Name',
                ),
                validator: (value) {
                  if (value.isEmpty) {
                    return 'Please enter your name';
                  }
                  return null;
                },
              ),
              TextFormField(
                controller: _ageController,
                decoration: InputDecoration(
                  labelText: 'Age',
                ),
                validator: (value) {
                  if (value.isEmpty) {
                    return 'Please enter your age';
                  }
                  if (int.tryParse(value) == null) {
                    return 'Please enter a valid age';
                  }
                  return null;
                },
              ),
              SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  if (_formKey.currentState.validate()) {
                    final jsonSchema = JsonSchema.fromJson({
                      'type': 'object',
                      'properties': {
                        'name': {'type': 'string'},
                        'age': {'type': 'integer'},
                      },
                    });

                    final jsonData = {
                      'name': _nameController.text,
                      'age': int.parse(_ageController.text),
                    };

                    final validationErrors = jsonSchema.validate(jsonData);
                    if (validationErrors.isEmpty) {
                      print('JSON data is valid!');
                    } else {
                      print('JSON data is invalid: $validationErrors');
                    }
                  }
                },
                child: Text('Validate JSON'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// The application flow is as follows:
// 1. The user enters their name and age in the text fields.
// 2. When the user clicks the "Validate JSON" button, the form is validated.
// 3. If the form is valid, a JSON schema is created to validate the user's input.
// 4. The user's input is converted to a JSON object and validated against the schema.
// 5. If the JSON data is valid, a success message is printed to the console.
// 6. If the JSON data is invalid, an error message is printed to the console with the validation errors.

```

<-- END_MAIN -->