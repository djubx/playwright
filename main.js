// depends on prompts.json only. It takes the prompts and generates the blogs. (Prompts are generated by prompt-manager.js)

const { chromium } = require('playwright');
const fs = require('fs').promises;
const path = require('path');

async function launchBrowser() {
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext();
  const page = await context.newPage();
  return { browser, context, page };
}

async function login(page) {
  console.log("Navigating to the website...");
  await page.goto('https://apps.abacus.ai/chatllm/62d3636d8/?forceAppId=62d3636d8');
  console.log("Website loaded successfully.");

  console.log("Logging in...");
  await page.waitForSelector('input[placeholder=" Email"]');
  await page.fill('input[placeholder=" Email"]', 'contact.dheeraj.jha@gmail.com');
  await page.waitForSelector('input[placeholder=" Password"]');
  await page.fill('input[placeholder=" Password"]', 'Flower1!!Flower1!!');
  await page.click('button[type="submit"]');

  console.log("Waiting for logged-in state...");
  await page.waitForSelector('textarea[placeholder="Write something..."]', { timeout: 8000000 });
  console.log("Logged in successfully.");
}

async function loadPrompts() {
  console.log("Loading prompts from JSON file...");
  const promptsJson = await fs.readFile('prompts.json', 'utf-8');
  const prompts = JSON.parse(promptsJson);
  console.log(`Loaded ${prompts.length} prompts.`);
  return prompts;
}

async function enterPrompt(page, command, isFirstPrompt) {
  if (isFirstPrompt) {
    console.log("Filling prompt input...");
    await page.fill('textarea[placeholder="Write something..."]', command);
  } else {
    console.log("Editing existing prompt...");
    await page.evaluate(() => {
      const hiddenElement = document.querySelector('.cursor-pointer.hidden.p-1');
      if (hiddenElement) {
        hiddenElement.click();
      }
    });
    await page.fill('#text', command);
  
    console.log("Clicking Regenerate button...");
    await page.click('button:has-text("Regenerate")');
  }
  
  console.log(`Prompt entered and Regenerate clicked: "${command}"`);
}

async function sendPrompt(page) {
  console.log("Waiting for send button to be visible and clicking it...");
  await page.waitForTimeout(2000);
  await page.waitForSelector('button:has(svg.fa-paper-plane)', { visible: true, timeout: 3000000 });
  await page.waitForTimeout(2000);
  await page.click('button:has(svg.fa-paper-plane)');
  console.log("Send button clicked.");
}

async function waitForResponse(page, context) {
  console.log("Waiting for response...");
  await page.waitForSelector('button:has(svg.fa-clipboard)', { timeout: 300000 });
  console.log("Response received and copy button is visible.");

  await context.grantPermissions(["clipboard-read", "clipboard-write"]);
  await page.waitForTimeout(1000);

  console.log("Clicking copy button...");
  await page.click('button:has(svg.fa-clipboard)');
  console.log("Copy button clicked.");
}

async function extractClipboardText(page) {
  console.log("Extracting response text from clipboard...");
  return await page.evaluate(async () => {
    try {
      return await navigator.clipboard.readText();
    } catch (err) {
      console.error('Failed to read clipboard contents: ', err);
      return null;
    }
  });
}

async function saveResponse(clipboardText, packageName, command) {
  if (clipboardText) {
    const filePath = path.join('packages', `${packageName}.txt`);
    console.log(`Saving response to file: ${filePath}`);
    await fs.mkdir('packages', { recursive: true });
    await fs.writeFile(filePath, clipboardText);
    console.log(`Response saved to file: ${filePath}`);
  } else {
    console.log("Failed to extract text from clipboard.");
    const errorFilePath = path.join('packages', `error_${packageName}.txt`);
    await fs.mkdir('packages', { recursive: true });
    await fs.writeFile(errorFilePath, `Failed to extract text from clipboard for prompt: ${command}`);
  }
}

async function handleError(page, packageName, command, error) {
  console.error(`Error processing response:`, error);
  const errorFilePath = path.join('packages', `error_${packageName}.txt`);
  await fs.mkdir('packages', { recursive: true });
  await fs.writeFile(errorFilePath, `Error processing prompt: ${command}\nError: ${error.message}`);
  const screenshotPath = path.join('screenshots', `error_screenshot_${packageName}.png`);
  await fs.mkdir('screenshots', { recursive: true });
  await page.screenshot({ path: screenshotPath });
  console.log(`Error screenshot saved as '${screenshotPath}'`);
}

async function processPrompts(page, context, prompts) {
  for (let i = 0; i < prompts.length; i++) {
    const { packageName, command } = prompts[i];
    console.log(`\nProcessing prompt ${i+1} of ${prompts.length}`);

    try {
      await enterPrompt(page, command, i === 0);
      await sendPrompt(page);
      await waitForResponse(page, context);
      const clipboardText = await extractClipboardText(page);
      // take screenshot
      const screenshotPath = path.join('screenshots', `screenshot_${packageName}.png`);
      await fs.mkdir('screenshots', { recursive: true });
      await page.screenshot({ path: screenshotPath });
      await saveResponse(clipboardText, packageName, command);
    } catch (error) {
      await handleError(page, packageName, command, error);
    }

    console.log("Waiting before next prompt...");
  }
}

async function main() {
  let browser, context, page;
  try {
    ({ browser, context, page } = await launchBrowser());
    await login(page);
    // wait for 20 seconds
    await page.waitForTimeout(10000);
    const prompts = await loadPrompts();
    await processPrompts(page, context, prompts);
    console.log("\nAll prompts processed successfully.");
  } catch (error) {
    console.error('An error occurred:', error);
    if (page) {
      const errorScreenshotPath = path.join('screenshots', 'error-screenshot.png');
      await fs.mkdir('screenshots', { recursive: true });
      await page.screenshot({ path: errorScreenshotPath });
      console.log(`Error screenshot saved as '${errorScreenshotPath}'`);
    }
  } finally {
    if (browser) {
      console.log("Closing browser...");
      await browser.close();
      console.log("Browser closed.");
    }
  }
}

main();